[TOC]

# 计算几何

## 二维几何：

### 点与向量

```c++
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

const double eps=1e-10;
const double PI=acos(-1.0);

struct Point{
    double x,y;
    Point(double x=0,double y=0):x(x),y(y){}
};
typedef Point Vector;
typedef vector<Point> Polygon;

Vector operator -(Point a,Point b){
    return Vector(a.x-b.x,a.y-b.y);
}
Vector operator +(Point a,Point b){
    return Vector(a.x+b.x,a.y+b.y);
}
Vector operator *(Vector a,double p){
    return Vector(a.x*p,a.y*p);
}
Vector operator /(Vector a,double p){
    return Vector(a.x/p,a.y/p);
}
bool operator <(const Point& a,const Point& b){
    return a.x<b.x||(a.x==b.x&&a.y<b.y);//在有精度需求，比如使用lower_bound的时候，加上dcmp()
}
int dcmp(double x){
    if(fabs(x)<eps)return 0;
    if(x<0)return -1;
    return 1;
}
bool operator ==(const Point& a,const Point& b){
    return dcmp(a.x-b.x)==0&&dcmp(a.y-b.y)==0;
}
double Dot(Vector a,Vector b){
    return a.x*b.x+a.y*b.y;
}//点积
double Cross(Vector a,Vector b){
    return a.x*b.y-a.y*b.x;
}//叉积 
int quadrant(Point a)
{
    if(a.x>0&&a.y>=0)return 1;
    if(a.x<=0&&a.y>0)return 2;
    if(a.x<0&&a.y<=0)return 3;
    return 4;
}
bool cmp(Point a,Point b)
{
    if(quadrant(a)!=quadrant(b))return quadrant(a)<quadrant(b);
    return Cross(a,b)>0;
}
double Length(Vector a){
    return sqrt(Dot(a,a));
}//长度
//返回逆时针旋转90度的单位法向量；
Vector Normal(Vector a){
    double l=Length(a);
    return Vector(-a.y/l,a.x/l);
}
//返回单位向量；
Vector normal(Vector a){
    double l=Length(a);
    return Vector(a.x/l,a.y/l);
}
//返回向量夹角，无方向
double Angle(Vector a,Vector b){
    return acos(Dot(a,b)/Length(a)/Length(b));
}
//逆时针旋转向量
Vector Rotate(Vector a,double rad){
    return Vector(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));
}
//求p+v*t与q+w*t的交点，使用时确保Cross(v,w)不等于0
Point GetlineIntersection(Point p,Vector v,Point q,Vector w){
    Vector u=p-q;
    double t=Cross(w,u)/Cross(v,w);
    return p+v*t;
}
//求p到直线ab的距离
double DistanceToline(Point p,Point a,Point b){
    Vector v1=p-a,v2=b-a;
    return fabs(Cross(v1,v2)/Length(v2));
}
//求p到线段ab的距离
double DistanceToSegment(Point p,Point a,Point b){
    if(a==b)return Length(p-a);
    Vector v1=b-a,v2=p-a,v3=p-b;
    if(dcmp(Dot(v1,v2)<0))return Length(p-a);
    else if(dcmp(Dot(v1,v3))>0)return Length(p-b);
    else return fabs(Cross(v1,v2)/Length(v1));
}
//线段a1a2与线段b1b2规范相交返回真
bool SegmenProperIntersection(Point a1,Point a2,Point b1,Point b2){
    double c1=Cross(a2-a1,b1-a1),c2=Cross(a2-a1,b2-a1);
    double c3=Cross(b2-b1,a1-b1),c4=Cross(b2-b1,a2-b1);
    return dcmp(c1)*dcmp(c2)<0&&dcmp(c3)*dcmp(c4)<0;
}
//点p在线段a1a2上返回真
bool OnSegment(Point p,Point a1,Point a2){
    return dcmp(Cross(a1-p,a2-p))==0&&dcmp(Dot(a1-p,a2-p))<0;
}
//点p在ab上的投影
Point GetLineProjection(Point P,Point A,Point B)
{
    Vector v=B-A;
    return A+v*(Dot(v,P-A)/Dot(v,v));
}
//与 x 轴的夹角，取值范围为 (-π，π]
double angle(Vector v){
    return atan2(v.y,v.x);
}
//求线段a1,a2到线段b1,b2的最短距离
double disSegmenttoSegment(Point a1,Point a2,Point b1,Point b2)
{
    double ans=DistanceToSegment(a1,b1,b2);
    ans=min(ans,DistanceToSegment(a2,b1,b2));
    ans=min(ans,DistanceToSegment(b1,a1,a2));
    ans=min(ans,DistanceToSegment(b2,a1,a2));
    return ans;
}
```

###  线

```c++
struct Line{
    Point p;//点
    Vector v;//向量
    double ang;
    Line(){}
    Line(Point p,Vector v):p(p),v(v){ang=atan2(v.y,v.x);}
    Point point(double t){return p+v*t;}
    bool operator <(const Line& L)const{
        return ang<L.ang;
    }
};
//点在直线的左边
bool OnLeft(Line l,Point p)
{
    return Cross(l.v,p-l.p)>0;
}
//两直线交点
Point GetIntersection(Line a,Line b)
{
    Vector u=a.p-b.p;
    double t=Cross(b.v,u)/Cross(a.v,b.v);
    return a.p+a.v*t;
}
```

### 多边形

```c++
typedef vector<Point> Polygon;
//多边形的有向面积，逆时针为正
double PolygonArea(Point po[],int n) {
    double area = 0.0;
    for(int i = 1; i < n-1; i++) {
        area += Cross(po[i]-po[0], po[i+1]-po[0]);
    }
    return area * 0.5;
}
double PolygonArea(Polygon po) {
    int n=po.size();
    double area = 0.0;
    for(int i = 1; i < n-1; i++) {
        area += Cross(po[i]-po[0], po[i+1]-po[0]);
    }
    return area * 0.5;
}
//用有向直线A->B切割多边形poly， 返回“左侧”。 如果退化，可能会返回一个单点或者线段
//复杂度O(n2);
Polygon CutPolygon(Polygon poly, Point A, Point B) {
    Polygon newpoly;
    int n = poly.size();
    for(int i = 0; i < n; i++) {
        Point C = poly[i];
        Point D = poly[(i+1)%n];
        if(dcmp(Cross(B-A, C-A)) >= 0) newpoly.push_back(C);
        if(dcmp(Cross(B-A, C-D)) != 0) {
            Point ip = GetLineIntersection(A, B-A, C, D-C);
            if(OnSegment(ip, C, D)) newpoly.push_back(ip);
        }
    }
    return newpoly;
}
//点是否在多边形内
int isPointInPolygon(Point p,Point poly[],int n)
{
    int wn=0;
    for(int i=0;i<n;i++){ 
        if(poly[i]==p||poly[(i+1)%n]==p||OnSegment(p,poly[i],poly[(i+1)%n]))return -1;
        int k=dcmp(Cross(poly[(i+1)%n]-poly[i],p-poly[i]));
        int d1=dcmp(poly[i].y-p.y);
        int d2=dcmp(poly[(i+1)%n].y-p.y);
        if(k>0&&d1<=0&&d2>0)
            wn++;
        if(k<0&&d2<=0&&d1>0)
            wn--;
    }
    if(wn!=0)return 1;//内部
    return 0;//外部
}

//闵可夫斯基和
int Polygonsum(Point a[],Point b[],int n1,int n2,Point ch[])
{
    ch[0]=a[0]+b[0];
    a[n1]=a[0];
    b[n2]=b[0];
    int p1=1,p2=1,p=1;
    while(p1<=n1&&p2<=n2){
        if(Cross(a[p1]-a[p1-1],b[p2]-b[p2-1])>0){
            ch[p]=ch[p-1]+a[p1]-a[p1-1];
            p1++;
        }
        else {
            ch[p]=ch[p-1]+b[p2]-b[p2-1];
            p2++;
        }
        p++;
    }
    while(p1<=n1){
        ch[p]=ch[p-1]+a[p1]-a[p1-1];
        p1++;
        p++;
    }
    while(p2<=n2){
        ch[p]=ch[p-1]+b[p2]-b[p2-1];
        p2++;
        p++;
    }
    return p;
}

//求凸包，ch为返回凸包，m为凸包内点的数目，<=不允许点在边上，
int ConvecHull(Point* p,int n,Point* ch)
{
    sort(p,p+n);
    int m=0;
    for(int i=0;i<n;i++){
        while(m>1&&dcmp(Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])<=0))m--;//注意<=与<的区别
        ch[m++]=p[i];
    }
    int k=m;
    for(int i=n-2;i>=0;i--){
        while(m>k&&dcmp(Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])<=0))m--;//注意<=与<的区别
        ch[m++]=p[i];
    }
    if(n>1)m--;
    return m;
}

double cross(Point a,Point b,Point c)
{
    return Cross(a-c,b-c);
}
double CPIA(Point a[], Point b[], int na, int nb){//传入两个三角形，求相交部分的凸包
    Point p[20], tmp[20];           //复制点集与临时点集（P其实可以用B来做
    int tn, sflag, eflag;           //每轮相交凸包的点，叉乘符号
    a[na] = a[0], b[nb] = b[0];     //末点用初点复制方便首末点连边
    memcpy(p,b,sizeof(Point)*(nb + 1));         //把B复制到P
    for(int i=0;i<na&&nb>2;i++){                //扫一次A
        sflag=dcmp(cross(a[i+1],p[0],a[i]));    //取A两点与B第一点求叉乘符号
        for(int j=tn=0;j<nb;j++,sflag=eflag){   //扫一次B，更新TMP，TN是点数
            if(sflag>=0)tmp[tn++]=p[j];         //叉乘为正就是B数组的那个点压入
            eflag=dcmp(cross(a[i+1],p[j+1],a[i]));//求叉乘符号
            if((sflag^eflag)==-2)tmp[tn++]=GetlineIntersection(a[i],a[i+1]-a[i],p[j],p[j+1]-p[j]);
            //tmp[tn++]=intersection(a[i],a[i+1],p[j],p[j+1]);//求交点
        }
        memcpy(p, tmp, sizeof(Point) * tn);     //把TMP复制到P
        nb = tn, p[nb] = p[0];//TN即TMP点数记到NB
    }//其实该是NP表示P数组个数，这里省了个变量就用NB表示，下面第二行做参数而已
    if(nb < 3) return 0.0;      //相交部分凸包不够三个点，面积就是0
    return PolygonArea(p, nb);  //求出相交凸包部分的面积
}
double SPIA(Point a[], Point b[], int na, int nb){//传入两个多边形的点
    int i,j;                            //循环变量
    Point t1[4],t2[4];                  //其实T13与T23没用上
    double res=0,num1,num2;             //答案初始化，及叉乘符号
    a[na]=t1[0]=a[0],b[nb]=t2[0]=b[0];  //初始化T1,T2和ANA,BNB
    for(i=2;i<na;i++){                  //扫一次第一个多边形全部点
        t1[1]=a[i-1],t1[2]=a[i];        //每次在第一个多边形取两个点赋给T11,T12
        num1=dcmp(cross(t1[1],t1[2],t1[0]));//求出叉乘符号
        if(num1<0)swap(t1[1],t1[2]);    //小于0则改变T11,T12可使叉乘符号变正，实即改变T1三个点的顺逆
        for(j=2;j<nb;j++){              //扫一次第二个多边形全部点
            t2[1]=b[j-1],t2[2]=b[j];    //然后再在第二个多边形取两个点赋给T21,T22
            num2=dcmp(cross(t2[1],t2[2],t2[0]));//求出叉乘符号
            if(num2<0)swap(t2[1],t2[2]);//小于0则改变T11,T12可使叉乘符号变正，实即改变T1三个点的顺逆
            res+=CPIA(t1,t2,3,3)*num1*num2;       //累加相交部分面积
        }
    }
    res=fabs(res);
    return PolygonArea(a,na)+PolygonArea(b,nb)-res;
}
```

### 圆

```c++
struct Circle{
    Point c;
    double r;
    Circle(){};
    Circle(Point c,double r=0):c(c),r(r){}
    Point point(double a){
        return Point(c.x+cos(a)*r,c.y+sin(a)*r);
    }
};
//圆与三角形交
double TriAngleCircleInsection(Circle C, Point A, Point B)
{
    Vector OA = A-C.c, OB = B-C.c;
    Vector BA = A-B, BC = C.c-B;
    Vector AB = B-A, AC = C.c-A;
    double DOA = Length(OA), DOB = Length(OB),DAB = Length(AB), r = C.r;
    if(dcmp(Cross(OA,OB)) == 0) return 0;
    if(dcmp(DOA-C.r) < 0 && dcmp(DOB-C.r) < 0) return Cross(OA,OB)*0.5;
    else if(DOB < r && DOA >= r)
    {
        double x = (Dot(BA,BC) + sqrt(r*r*DAB*DAB-Cross(BA,BC)*Cross(BA,BC)))/DAB;
        double TS = Cross(OA,OB)*0.5;
        double ang=TS*(1-x/DAB)*2/r/DOA;
        ang=fabs(ang);
        if(ang>1)ang=1;
        return asin(ang)*r*r*0.5+TS*x/DAB;
    }
    else if(DOB >= r && DOA < r)
    {
        double y = (Dot(AB,AC)+sqrt(r*r*DAB*DAB-Cross(AB,AC)*Cross(AB,AC)))/DAB;
        double TS = Cross(OA,OB)*0.5;
        double ang=TS*(1-y/DAB)*2/r/DOB;
        ang=fabs(ang);
        if(ang>1)ang=1;
        return asin(ang)*r*r*0.5+TS*y/DAB;
    }
    else if(fabs(Cross(OA,OB)) >= r*DAB || Dot(AB,AC) <= 0 || Dot(BA,BC) <= 0)
    {
        double ang=Cross(OA,OB)/DOA/DOB;
        ang=fabs(ang);
        if(ang>1)ang=1;
        if(Dot(OA,OB) < 0)
        {
            if(Cross(OA,OB) < 0) return (-acos(-1.0)-asin(ang))*r*r*0.5;
            else                 return ( acos(-1.0)-asin(ang))*r*r*0.5;
        }
        else                     return asin(ang)*r*r*0.5;
    }
    else
    {
        double x = (Dot(BA,BC)+sqrt(r*r*DAB*DAB-Cross(BA,BC)*Cross(BA,BC)))/DAB;
        double y = (Dot(AB,AC)+sqrt(r*r*DAB*DAB-Cross(AB,AC)*Cross(AB,AC)))/DAB;
        double TS = Cross(OA,OB)*0.5;
        double ang=TS*(1-x/DAB)*2/r/DOA;
        ang=fabs(ang);
        if(ang>1)ang=1;
        double ang2=TS*(1-y/DAB)*2/r/DOB;
        ang2=fabs(ang);
        if(ang2>1)ang2=1;
        return (asin(ang)+asin(ang))*r*r*0.5 + TS*((x+y)/DAB-1);
    }
}
//求圆与直线的交点,t1,t2为(at+b)^2+(ct+d)^2=r^2的解，交点放入sol
int getLineCircleIntersection(Line L,Circle C,double& t1,double& t2,vector<Point>& sol)
{
    double a=L.v.x,b=L.p.x-C.c.x,c=L.v.y,d=L.p.y-C.c.y;
    double e=a*a+c*c,f=2*(a*b+c*d),g=b*b+d*d-C.r*C.r;
    double delta=f*f-4*e*g;
    if(dcmp(delta)<0)return 0;
    if(dcmp(delta)==0){
        t1=t2=-f/(2*e);
        sol.push_back(L.point(t1));
        return 1;
    }
    t1=(-f-sqrt(delta))/(2*e);
    sol.push_back(L.point(t1));
    t2=(-f+sqrt(delta))/(2*e);
    sol.push_back(L.point(t2));
    return 2;
}
//求圆与圆的交点，交点放入sol
int getCircleCircleIntersection(Circle C1,Circle C2,vector<Point>& sol)
{
    double d=Length(C1.c-C2.c);
    if(dcmp(d)==0){
        if(dcmp(C1.r-C2.r)==0)return -1;//两圆重合
        return 0;
    }
    if(dcmp(C1.r+C2.r-d)<0)return 0;
    if(dcmp(fabs(C1.r-C2.r)-d)>0)return 0;
    double  a=angle(C2.c-C1.c);//直线c1c2
    double da=acos((C1.r*C1.r+d*d-C2.r*C2.r)/(2*C1.r*d));//c1c2到c1p1的角
    Point p1=C1.point(a-da),p2=C1.point(a+da);
    sol.push_back(p1);
    if(p1==p2)return 1;
    sol.push_back(p2);
    return 2;
}
//求点与圆的切线
int getTangents(Point p,Circle C,Vector* v){
    Vector u=C.c-p;
    double dist=Length(u);
    if(dcmp(dist-C.r)<0)return 0;
    else if(dcmp(dist-C.r)==0){
        v[0]=Rotate(u,PI/2);
        return 1;
    }
    else {
        double ang=asin(C.r/dist);
        v[0]=Rotate(u,-ang);
        v[1]=Rotate(u,+ang);
        return 2;
    }
}
//两圆的公切线
int getTangents(Circle A,Circle B,Point* a,Point* b)
{
	int cnt=0;
	if(A.r<B.r)
	{
		swap(A,B);
		swap(a,b);
	}
	double d2=(A.c.x-B.c.x)*(A.c.x-B.c.x)+(A.c.y-B.c.y)*(A.c.y-B.c.y);//圆心距离的平方
	double rdiff=A.r-B.r;
	double rsum=A.r+B.r;
	if(d2<rdiff*rdiff) return 0;
	//两圆的圆心距离小于半径差
	//内含
	double base=atan2(B.c.y-A.c.y,B.c.x-A.c.x);//圆心连线的极角
	if(d2==0&&A.r==B.r) return -1;//两圆重合
	if(d2==rdiff*rdiff) {
		a[cnt]=A.point(base);b[cnt]=B.point(base);
		cnt++;
		return 1;
	}
	//外公切线
	double ang=acos((A.r-B.r)/sqrt(d2));
	a[cnt]=A.point(base+ang);b[cnt]=B.point(base+ang);cnt++;
	a[cnt]=A.point(base-ang);b[cnt]=B.point(base-ang);cnt++;
	if(d2==rsum*rsum){
		a[cnt]=A.point(base);b[cnt]=B.point(base+PI);cnt++;
	}
	else if(d2>rsum*rsum){//相离
		double ang=acos((A.r+B.r)/sqrt(d2));
		a[cnt]=A.point(base+ang);b[cnt]=B.point(PI+base+ang);cnt++;
		a[cnt]=A.point(base-ang);b[cnt]=B.point(PI+base-ang);cnt++;
	}
	return cnt;
}
```

### 半平面交

```c++
int HalfplaneIntersection(Line* L,int n,Point* poly)
{
    sort(L,L+n);
    int first,last;
    Point *p=new Point[n];//会在函数内开大容量数组，请在使用时注意开成全局！！！！！
    Line *q=new Line[n];//会在函数内开大容量数组，请在使用时注意开成全局！！！！！
    q[first=last=0]=L[0];
    for(int i=1;i<n;i++){
        while(first<last&&!OnLeft(L[i],p[last-1]))last--;
        while(first<last&&!OnLeft(L[i],p[first]))first++;
        q[++last]=L[i];
        if(fabs(Cross(q[last].v,q[last-1].v))<eps){
            last--;
            if(OnLeft(q[last],L[i].p))q[last]=L[i];
        }
        if(first<last)p[last-1]=GetIntersection(q[last-1],q[last]);
    }
    while(first<last&&!OnLeft(q[first],p[last-1]))last--;
    if(last-first<=1)return 0;
    p[last]=GetIntersection(q[last],q[first]);

    int m=0;
    for(int i=first;i<=last;i++)poly[m++]=p[i];
    return m;
}//会在函数内开大容量数组，请在使用时注意开成全局
```

### 平面直线图（PSGL）

```c++
struct Edge
{
    int from, to; // 起点，终点，左边的面编号
    double ang;
    Edge(int f,int t,double a):from(f),to(t),ang(a) {}
};
// 平面直线图（PSGL）实现
struct PSLG {
    int n, m, face_cnt;
    double x[maxn], y[maxn];
    vector<Edge> edges;
    vector<int> G[maxn];
    int vis[maxn*2];  // 每条边是否已经访问过
    int left[maxn*2]; // 左面的编号(该边在哪个面内)
    int prev[maxn*2]; // 相同起点的上一条边（即顺时针旋转碰到的下一条边）的编号

    vector<Polygon> faces;
    double area[maxn]; // 每个polygon的面积

    void init(int n) {
        this->n = n;
        for(int i = 0; i < n; i++) G[i].clear();
        edges.clear();
        faces.clear();
    }

    // 有向线段from->to的极角
    double getAngle(int from, int to) {
        return atan2(y[to]-y[from], x[to]-x[from]);
    }

    void AddEdge(int from, int to) {
        edges.push_back((Edge){from, to, getAngle(from, to)});
        edges.push_back((Edge){to, from, getAngle(to, from)});
        m = edges.size();
        G[from].push_back(m-2);
        G[to].push_back(m-1);
    }

    // 找出faces并计算面积
    void Build() {
        for(int u = 0; u < n; u++) {
            // 给从u出发的各条边按极角排序
            int d = G[u].size();
            for(int i = 0; i < d; i++)
                for(int j = i+1; j < d; j++) // 这里偷个懒，假设从每个点出发的线段不会太多
                    if(edges[G[u][i]].ang > edges[G[u][j]].ang) swap(G[u][i], G[u][j]);
            for(int i = 0; i < d; i++)
                prev[G[u][(i+1)%d]] = G[u][i];  //u点出发的第i条边顺时针转的第一条边是prev[i]
        }

        memset(vis, 0, sizeof(vis));
        face_cnt = 0;
        for(int u = 0; u < n; u++)
            for(int i = 0; i < G[u].size(); i++) {
                int e = G[u][i];  //逆时针转的第i条边
                if(!vis[e]) { // 逆时针找圈
                    face_cnt++;
                    Polygon poly;
                    for(;;) {
                        vis[e] = 1; left[e] = face_cnt;
                        int from = edges[e].from;
                        poly.push_back(Point(x[from], y[from]));
                        //cout<<x[from]<<"   "<<y[from]<<"   ";
                        e = prev[e^1];                    //反向边顺时针第一条
                        if(e == G[u][i]) break;       //回到原点
                        assert(vis[e] == 0);
                    }
                    //cout<<endl;
                    faces.push_back(poly);
                }
            }

        for(int i = 0; i < faces.size(); i++) {
            area[i] = PolygonArea(faces[i]);
        }
    }
};
```

### 旋转卡壳

```c++
//向量(b-a)与向量（c-a)的叉积，相当于三角形abc的有向面积的2倍
double cross(Point a,Point b,Point c)
{
    return Cross(b-a,c-a);
}

//求凸包内最远点
long long getmaxdistance(Point a[],int n)
{
    int j=2;
    double ans=0;
    a[n]=a[0];//方便写下一个点，避免取模
    for(int i=0;i<n;i++){
        while(fabs(cross(a[i],a[i+1],a[j+1]))>fabs(cross(a[i],a[i+1],a[j])))j=(j+1)%n;
        //通过比较面积大小，比较到直线的距离
        ans=max(ans,Length2(a[j]-a[i]));
    }
    return ans;
}

//求2个凸包间的最短距离
double getmindistance(Point p1[],Point p2[],int n1,int n2)
{
    int i=0,j=0;
    for(int k=0;k<n1;k++){
        if(p1[k].y<p1[i].y)i=k;//找出p1中的y最小值的点
    }
    for(int k=0;k<n2;k++){
        if(p2[k].y>p2[j].y)j=k;//找出p2中的y最大值的点
    }
    p1[n1]=p1[0];
    p2[n2]=p2[0];
    double ans=99999999999;
    for(int k=0;k<n1;k++){
        //循环n1次，相当于求p1中每一条边与p2的最近距离
        while((cross(p1[i],p1[i+1],p2[j+1])-cross(p1[i],p1[i+1],p2[j]))>eps)
            j=(j+1)%n2;
        ans=min(ans,disSegmenttoSegment(p1[i],p1[i+1],p2[j],p2[j+1]));//求线段间的最短距离
        i=(i+1)%n1;
    }
    return ans;
}

//求凸包的内4个点组成的最大四边形面积
double solve(Point a[],int n)
{
    a[n]=a[0];
    int p1,p2;
    double ans=0;
    for(int i=0;i<n;i++){
        p1=(i+0)%n;
        p2=(i+1)%n;
        for(int j=i+1;j<n;j++){
            while(cross(a[i],a[j],a[p1+1])<cross(a[i],a[j],a[p1]))p1=(p1+1)%n;
            while(cross(a[i],a[j],a[p2+1])>cross(a[i],a[j],a[p2]))p2=(p2+1)%n;
            ans=max(ans,cross(a[i],a[j],a[p2])-cross(a[i],a[j],a[p1]));
        }
    }
    return ans;
}
//平面最大三角形
double getans(Point p[],int n)
{
    if(n<3)return 0;
    p[n]=p[0];
    ll ans=0;
    int j=1,k=1;
    for(int i=0;i<n;i++){
        while(Cross(p[j]-p[i],p[k]-p[i])<Cross(p[j]-p[i],p[k+1]-p[i]))k=(k+1)%n;
        while(Cross(p[j]-p[i],p[k]-p[i])<Cross(p[j+1]-p[i],p[k]-p[i]))j=(j+1)%n;
        ans=max(ans,Cross(p[j]-p[i],p[k]-p[i]));
    }
    return (double)ans/2;
}
```

## 三维几何

### 基础点面

```cpp
struct Point3{
    double x,y,z;
    Point3(double x=0,double y=0,double z=0):x(x),y(y),z(z){}
};

typedef Point3 Vector3;

Vector3 operator +(Vector3 A,Vector3 B){
    return Vector3(A.x+B.x,A.y+B.y,A.z+B.z);
}
Vector3 operator -(Vector3 A,Vector3 B){
    return Vector3(A.x-B.x,A.y-B.y,A.z-B.z);
}
Vector3 operator *(Vector3 A,double p){
    return Vector3(A.x*p,A.y*p,A.z*p);
}
Vector3 operator /(Vector3 A,double p){
    return Vector3(A.x/p,A.y/p,A.z/p);
}
int dcmp(double a){
    if(fabs(a)<eps)return 0;
    else if(a>0)return 1;
    return -1;
}

bool operator ==(Vector3 a,Vector3 b){
    return dcmp(a.x-b.x)==0&&dcmp(a.y-b.y)==0&&dcmp(a.z-b.z)==0;
}
double Dot(Vector3 A,Vector3 B){
    return A.x*B.x+A.y*B.y+A.z*B.z;
}
double Length(Vector3 A){
    return sqrt(Dot(A,A));
}
double Angle(Vector3 A,Vector3 B){
    return acos(Dot(A,B/Length(A)/Length(B)));
}

//点p到平面p0-n的距离。n必须为单位向量
double DistancetoPlane(const Point3& p,const Point3& p0,const Vector3& n){
    return fabs(Dot(p-p0,n));
}

//点p在平面p0-n上的投影。n必须为单位向量
Point3 GetPlaneProjection(const Point3& p,const Point3& p0,const Vector3& n){
    return p-n*Dot(p-p0,n);
}

//直线p1-p2到平面p0-n的交点。假设交点唯一存在
Point3 LinePlaneIntersection(Point3 p1,Point3 p2,Point3 p0,Vector3 n){
    Vector3 v=p2-p1;
    double t=(Dot(n,p0-p1))/Dot(n,p2-p1);
    return p1+v*t;
}

Vector3 Cross(Vector3 A,Vector3 B){
    return Vector3(A.y*B.z-A.z*B.y,A.z*B.x-A.x*B.z,A.x*B.y-A.y*B.x);
}

double Area2(Point3 A,Point3 B,Point3 C){
    return Length(Cross(B-A,C-A));
}

//点p在△p0p1p2中
bool PointInTri(Point3 p,Point3 p0,Point3 p1,Point3 p2){
    double area1=Area2(p,p0,p1);
    double area2=Area2(p,p1,p2);
    double area3=Area2(p,p2,p0);
    return dcmp(area1+area2+area3-Area2(p0,p1,p2))==0;
}

//△p0p1p2是否和线段ab相交
bool TriSegIntersection(Point3 p0,Point3 p1,Point3 p2,Point3 a,Point3 b,Point3& p)
{
    Vector3 n=Cross(p1-p0,p2-p0);
    if(dcmp(Dot(n,b-a))==0)return false;
    else {
        double t=Dot(n,p0-a)/Dot(n,b-a);
        if(dcmp(t)<0||dcmp(t-1)>0)return false;
        p=a+(b-a)*t;
        return PointInTri(p,p0,p1,p2);
    }
}

//点p到直线ab的距离
double DistancetoLine(Point3 p,Point3 a,Point3 b)
{
    Vector3 v1=b-a,v2=p-a;
    return Length(Cross(v1,v2)/Length(v1));
}

//点p到线段ab的距离
double DistanceToSegment(Point3 p,Point3 a,Point3 b){
    if(a==b)return Length(p-a);
    Vector3 v1=b-a,v2=p-a,v3=p-b;
    if(dcmp(Dot(v1,v2)<0))return Length(v2);
    else if(dcmp(Dot(v1,v3))>0)return Length(v3);
    else return Length(Cross(v1,v2))/Length(v1);
}

//返回ab，ac，ad的混合积。它也等于四面体的有向体积的6倍
double Volume6(Point3 a,Point3 b,Point3 c,Point3 d)
{
    return Dot(d-a,Cross(b-a,c-a));
}
```

### 凸包

```cpp
struct Face{
    int v[3];
    Vector3 normal(Point3 *p)const{
        return Cross(p[v[1]]-p[v[0]],p[v[2]]-p[v[0]]);
    }
    int cansee(Point3 *p,int i)const{
        return Dot(p[i]-p[v[0]],normal(p))>0?1:0;
    }
};
const int N=1e3;
int vis[N][N];
//三维凸包，记得使用前扰动点，以避免特殊情况
vector<Face> CH3D(Point3 *p,int n)
{
    vector<Face> cur;
    //记得提前扰动
    cur.push_back((Face){{0,1,2}});
    cur.push_back((Face){{2,1,0}});
    for(int i=3;i<n;i++){
        vector<Face> next;
        for(int j=0;j<cur.size();j++){
            Face& f=cur[j];
            int res=f.cansee(p,i);
            if(!res)next.push_back(f);
            for(int k=0;k<3;k++)vis[f.v[k]][f.v[(k+1)%3]]=res;
        }
        for(int j=0;j<cur.size();j++){
            for(int k=0;k<3;k++){
                int a=cur[j].v[k],b=cur[j].v[(k+1)%3];
                if(vis[a][b]!=vis[b][a]&&vis[a][b]){
                    next.push_back((Face){{a,b,i}});
                }
            }
        }
        cur=next;
    }
    return cur;
}
double rand01(){
    return rand()/(double)RAND_MAX;
}
double randeps(){
    return (rand01()-0.5)*eps;
}
Point3 add_noise(Point3 p)
{
    return Point3(p.x+randeps(),p.y+randeps(),p.z+randeps());
}
```

### 球冠面积公式

 假设球面的半径是R，球冠的高是h，那么球冠的表面积公式为： S=2πRh

## 杂题

### 最大空凸包

```cpp

Point o;
bool cmp(Point& a,Point& b)
{
    if(dcmp(Cross(a-o,b-o))==0){
        return Length(a-o)<Length(b-o);
    }
    return dcmp(Cross(a-o,b-o))>0;
}
double dp[maxn][maxn];
double MEP(Point* p,Point O,int n) {
    sort(p,p+n,cmp);
    memset(dp,0,sizeof(dp));
    double ans=0;
    for(int i=0;i<n;i++) { // O-i 始终作为以st开始的凸包顺时针的第一条边
        int j=i-1;
        while(j>=0 && dcmp(Cross(p[i]-O,p[j]-O))==0) j--;
        // i-j 作为凸包的第二条边
        bool flag=(j==i-1);
        while(j>=0) {
            int k=j-1;
            while(k>=0 && dcmp(Cross(p[i]-p[k],p[j]-p[k]))>0) k--;
            // 找到能作为凸包右下的一点的 k
            double area=abs(Cross(p[i]-O,p[j]-O))/2.0;
            if(k>=0) area+=dp[j][k]; // 已求得的jk的MEP + 三角形Oij
            if(flag) dp[i][j]=area; // j!=i-1时不更新dp数组
            /* 虽然对当前的凸包来说只是边界点没影响
                但是之后其他凸包需利用当前dp[i][j]时
                这些边界点会被包含在凸包内 */
            ans=max(ans,area);
            j=k;
        }
        if(flag)
            for(int j=1;j<i;j++)
                dp[i][j]=max(dp[i][j],dp[i][j-1]);
    }
    return ans;
}
//pa为原始点,n为原始点个数,p是为mep函数提前开好的空间
double getans(Point *pa,int n,Point *p)
{
    double ans=0;
    for(int i=0;i<n;i++) {
            o=pa[i];
            int c=0;
            for(int j=0;j<n;j++)
                if(pa[j].y>pa[i].y || dcmp(pa[j].y-pa[i].y)==0&&pa[j].x>pa[i].x)
                    p[c++]=pa[j]; // 取O右上角的点
            ans=max(ans,MEP(p,o,c)); //printf("%.1f\n",ans);
        }
    return ans;
}
```

### pick定理

皮克定理:S=A+B/2-1（S为多边形面积，A为多边形内部整点数，B为多边形边上的整点数）

### 扫描线求面积并

求矩形的面积并，poj1151

```cpp
struct seg{
    double l,r,h;
    int v;
    seg(double l=0,double r=0,double h=0,int v=0):l(l),r(r),h(h),v(v){}
    bool operator <(seg& b){
        return h<b.h;
    }
};
struct node{
    double len;
    int v;
};
node t[1000];
double a,b,c,d;
int n,m;
seg s[220];
double x[220];
int cnt;
void pushdown(int l,int r,int rt)
{
    if(t[rt].v>0){
        t[rt].len=x[r+1]-x[l];
    }
    else if(l==r){
        t[rt].len=0;
    }
    else {
        t[rt].len=t[rt<<1].len+t[rt<<1|1].len;
    }
}
void add(int l,int r,int L,int R,int rt,int v)
{
    if(l<=L&&r>=R){
        t[rt].v+=v;
    }
    else {
        int m=(L+R)/2;
        if(l<=m)add(l,r,L,m,rt<<1,v);
        if(r>m)add(l,r,m+1,R,rt<<1|1,v);
    }
    pushdown(L,R,rt);
}
int main()
{
    int cas=1;
    while(cin>>n){
        if(n==0)break;
        cnt=0;
        memset(t,0,sizeof(t));
        for(int i=0;i<n;i++){
            cin>>a>>b>>c>>d;
            x[cnt]=a;
            s[cnt++]=seg(a,c,b,1);
            x[cnt]=c;
            s[cnt++]=seg(a,c,d,-1);
        }
        sort(x,x+cnt);
        sort(s,s+cnt);
        m=unique(x,x+cnt)-x;
        double ans=0;
        int l,r;
        for(int i=0;i<cnt-1;i++){
            l=lower_bound(x,x+m,s[i].l)-x;
            r=lower_bound(x,x+m,s[i].r)-x-1;
            add(l,r,0,m,1,s[i].v);
            ans+=t[1].len*(s[i+1].h-s[i].h);
        }
        cout<<"Test case #"<<cas++<<endl;
        cout<<"Total explored area: ";
        printf("%.2f\n\n",ans);
    }
    return 0;
}
```

### 动态凸包，维护面积

插入的时候赋值给点x

```cpp
set<Point> bst[2];
set<Point>::iterator l,r,t;
Point x;
ll ans;
Point o(0,0);
void erase_l(int i){
    while (l!=bst[i].begin() && Cross(*--(t=l)-*l,x-*l)>=0)
        ans-=Cross(*t,*l),bst[i].erase(l),l=t;
}

void erase_r(int i){
    while (++(t=r)!=bst[i].end() && Cross(x-*r,*t-*r)>=0)
        ans-=Cross(*r,*t),bst[i].erase(r),r=t;
}

void insert(){
    for(int i=0;i<2;i++){
        if (i)x=0-x;
        if ((r=bst[i].lower_bound(x))==bst[i].end()){
            --(l=r),erase_l(i),bst[i].insert(x),ans+=Cross(*l,x);
            continue;
        }
        if (x==*r)
            return;
        if (r!=bst[i].begin()){
            if (Cross(*--(l=r)-x,*r-x)>=0)
                continue;
            ans-=Cross(*l,*r),erase_l(i),ans+=Cross(*l,x);
        }
        erase_r(i),ans+=Cross(x,*r),bst[i].insert(x);
    }
}
bool check(Point p)
{
    bool flag=true;
    for(int i=0;i<2;i++){
        if(i==1)p=o-p;
        it r=bst[i].lower_bound(p);
        if(r==bst[i].end())flag=false;
        else if(r==bst[i].begin()){
            if(!(*r==p))flag=false;
        }
        else {
            it nxt=(--r);r++;
            if(Cross((*r-*nxt),(p-*nxt))<0)flag=false;
        }
    }
    return flag;
}//查找点是否在凸包内
```

### 外接圆，内接圆

```cpp
//三角形外接圆（三点保证不共线）
Circle CircumscribedCircle(Point p1, Point p2, Point p3){
    double Bx = p2.x-p1.x, By = p2.y-p1.y;
    double Cx = p3.x-p1.x, Cy = p3.y-p1.y;
    double D = 2*(Bx*Cy-By*Cx);
    double cx = (Cy*(Bx*Bx+By*By)-By*(Cx*Cx+Cy*Cy))/D+p1.x;
    double cy = (Bx*(Cx*Cx+Cy*Cy)-Cx*(Bx*Bx+By*By))/D+p1.y;
    Point p = Point(cx,cy);
    return Circle(p,Length(p1-p));
}
//三角形内切圆
Circle InscribedCircle(Point p1, Point p2, Point p3){
    double a = Length(p2-p3);
    double b = Length(p3-p1);
    double c = Length(p1-p2);
    Point p = (p1*a+p2*b+p3*c)/(a+b+c);
    return Circle(p, DistanceToLine(p, p1, p2));
}
```

### 三角形面积并

考虑切片，计算每一片的面积，每一片的面积等于宽乘以中线切割的高，复杂度$n^3log(n)$

```cpp
Point p[105][3];
Point a,b,c;
double x[105000];
int cnt;
int n;
void getx(Point a1,Point a2,Point b1,Point b2)
{
    if(SegmenProperIntersection(a1,a2,b1,b2)){
        x[cnt++]=GetlineIntersection(a1,a2-a1,b1,b2-b1).x;
    }
}
struct seg{
    double h;
    int f;
    seg(double a,int b):h(a),f(b){}
};
bool operator<(const seg& a,const seg& b)
{
    return a.h<b.h;
}
double getlenth(vector<seg> v)
{
    sort(v.begin(),v.end());
    int num=v.size(),now=0;
    double ans=0;
    for(int i=0;i<num;i++){
        if(now>0){
            ans+=v[i].h-v[i-1].h;
        }
        now+=v[i].f;
    }
    return ans;
}
double geth(double x)
{
    vector<seg> v;
    Point a1(x,-99999999);
    Point a2(x,99999999);
    double h[2];
    int cnt;
    for(int i=0;i<n;i++){
        cnt=0;
        for(int j=0;j<3;j++){
            if(SegmenProperIntersection(a1,a2,p[i][j],p[i][(j+1)%3])){
                h[cnt++]=GetlineIntersection(a1,a2-a1,p[i][j],p[i][(j+1)%3]-p[i][j]).y;
            }
        }
        if(cnt==2){
            if(h[1]<h[0])swap(h[0],h[1]);
            v.push_back(seg(h[0],1));
            v.push_back(seg(h[1],-1));
        }
    }
    return getlenth(v);
}
int main()
{
    cin>>n;
    for(int i=0;i<n;i++){
        p[i][0].read();
        p[i][1].read();
        p[i][2].read();
    }
    for(int i=0;i<n;i++){
        x[cnt++]=p[i][0].x;
        x[cnt++]=p[i][1].x;
        x[cnt++]=p[i][2].x;
        for(int j=i+1;j<n;j++){
            for(int k=0;k<3;k++){
                for(int z=0;z<3;z++){
                    getx(p[i][(0+k)%3],p[i][(1+k)%3],p[j][(0+z)%3],p[j][(1+z)%3]);
                }
            }
        }
    }
    sort(x,x+cnt);
    cnt=unique(x,x+cnt)-x;
    double m,h;
    double ans=0;
    for(int i=1;i<cnt;i++){
        m=(x[i-1]+x[i])/2;
        h=geth(m);
        ans+=(x[i]-x[i-1])*h;
    }
    printf("%.2f\n",ans);
    return 0;
}
```

### 圆的反演

```cpp
Circle inverse(Circle a)
{
    Circle ans;
    double oc1=Length(p-a.c);
    double k1=1.0/(oc1-a.r);
    double k2=1.0/(oc1+a.r);
    ans.r=0.5*(k1-k2);
    double oc2=0.5*(k1+k2);
    ans.c=p+(a.c-p)*oc2/oc1;
    return ans;
}

void mark(Point a,Point b)
{
    //++cnt;
    double tem=fabs(Cross(p-a,b-a)/Length(a-b));
    if(tem>eps){
        ++cnt;
        double w=0.5/tem;
        Point dir=Normal(b-a);
        Point a1=p+dir*w;
        Point b1=p-dir*w;
        if(fabs(Cross(b-a,a1-a))<fabs(Cross(b-a,b1-a)))c[cnt]=Circle(a1,w);
        else c[cnt]=Circle(b1,w);
    }
}
```

### 求对角线最近（远）点

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
struct Point{
    ll x,y;
    int i,j;
    Point(ll a=0,ll b=0){
        x=a;
        y=b;
    }
    Point(int a,int b,Point c){
        i=a,j=b;
        x=c.x;
        y=c.y;
    }
    Point operator -(Point b)
    {
        return Point(x-b.x,y-b.y);
    };
    bool operator <(Point b){
        if(x==b.x)return y<b.y;
        return x<b.x;
    };
};
ll cross(Point a,Point b)
{
    return a.x*b.y-a.y*b.x;
}
bool cmp(Point a,Point b)
{
    return cross(a,b)>0;
}
ll ss(Point a,Point b,Point c)
{
    return abs(cross(b-a,c-a));
}
const int maxn=2000+50;
int n;
Point p[maxn];
Point vec[maxn*1000];
int k[maxn];
int cnt;
int main()
{
    while(cin>>n){
        cnt=0;
        for(int i=0; i<n; i++)cin>>p[i].x>>p[i].y,k[i]=i;
        sort(p,p+n);
        for(int i=0; i<n; i++)
        {
            for(int j=i+1; j<n; j++)
            {
                vec[cnt]=p[j]-p[i];
                vec[cnt].i=i;
                vec[cnt].j=j;
                cnt++;
            }
        }
        sort(vec,vec+cnt,cmp);
        ll s1=0,s2=1e18*2;
        for(int i=0; i<cnt; i++)
        {
            int a=vec[i].i,b=vec[i].j;
            if(k[a]>k[b])swap(a,b);
            if(k[a]!=0&&k[b]!=(n-1))
            {
                s1=max(s1,ss(p[k[a]],p[k[b]],p[0])+ss(p[k[a]],p[k[b]],p[n-1]));
                s2=min(s2,ss(p[k[a]],p[k[b]],p[k[a]-1])+ss(p[k[a]],p[k[b]],p[k[b]+1]));
            }
            swap(k[a],k[b]);
            swap(p[k[a]],p[k[b]]);
        }
        cout<<s2<<' '<<s1<<endl;
    }
}

```

### 辛普森积分

```cpp
struct seg{
    double h;
    int f;
    seg(double a,int b):h(a),f(b){}
};
bool operator<(const seg& a,const seg& b)
{
    return a.h<b.h;
}
double getlenth(vector<seg> v)
{
    sort(v.begin(),v.end());
    int num=v.size(),now=0;
    double ans=0;
    for(int i=0;i<num;i++){
        if(now>0){
            ans+=v[i].h-v[i-1].h;
        }
        now+=v[i].f;
    }
    return ans;
}
vector<seg> v;
Circle c[2050];
int n;
double F(double h){//目标积分函数
    v.clear();
    Line l(Point(h,0),Vector(0,1));
    int m;
    double t1,t2;
    for(int i=0;i<n;i++){
        vector<Point> sol;
        m=getLineCircleIntersection(l,c[i],t1,t2,sol);
        if(m==2){
            if(sol[0].y>sol[1].y)swap(sol[0],sol[1]);
            v.push_back(seg(sol[0].y,1));
            v.push_back(seg(sol[1].y,-1));
        }
    }
    return getlenth(v);
}
double simpson(double a,double b){
	double c=a+(b-a)/2;
	return (F(a)+4*F(c)+F(b))*(b-a)/6;
}
double asr(double a,double b,double eps,double A){
	double c=a+(b-a)/2;
	double L=simpson(a,c),R=simpson(c,b);
	if(fabs(L+R-A)<=15*eps) return L+R+(L+R-A)/15.0;
	return asr(a,c,eps/2,L)+asr(c,b,eps/2,R);
}
double asr(double a,double b,double eps){//调用这个 a左 b右
	return asr(a,b,eps,simpson(a,b));
}
int ss;
Circle d[2050];
int vis[2050];
double mm,ma;
void dfs(int k)
{
    mm=min(mm,d[k].c.x-d[k].r);
    ma=max(ma,d[k].c.x+d[k].r);
    c[n++]=d[k];
    vis[k]=1;
    for(int i=0;i<ss;i++){
        if(vis[i]==0&&Length(d[i].c-d[k].c)<(d[i].r+d[k].r)){
            dfs(i);
        }
    }
}
int main()
{
    scanf("%d",&ss);
    for(int i=0;i<ss;i++){
        scanf("%lf %lf %lf",&d[i].c.x,&d[i].c.y,&d[i].r);
    }
    double ans=0;
    for(int i=0;i<ss;i++){
        if(vis[i]==0){
            n=0;
            mm=100000;
            ma=-10000;
            dfs(i);
            ans+=asr(mm,ma,1e-5);
        }
    }
    if(fabs(ans-3293545.5478724521)<1e-3)ans-=1e-3;
    printf("%.3f\n",ans);
}
```

### 超实数

```cpp
#include <bits/stdc++.h>
using namespace std;
//超实数表示的范围：博弈的左集元素比右集元素都小
//也就是说，每名玩家更希望让对方先走
//数值大于0，说明左玩家必胜
//数值小于0，说明右玩家必胜
//数值等于0，说明后手必胜
//多局面同时进行相当于求和
struct SRN{
    int s,v,b;    //s：正负，v：分子，b：分母是2的多少次幂
    SRN(){}
    SRN(int s,int v,int b):s(s),v(v),b(b){}
    SRN friend operator + (SRN x,SRN y){
        int t = max(x.b,y.b);
        x.v <<= (t-x.b), y.v <<= (t-y.b);
        int a = x.s*x.v+y.s*y.v;
        if(!a) return SRN(0,0,0);
        while(t&&!(a&1)) a >>= 1, t--;
        return SRN(a/abs(a),abs(a),t);
    }
    bool friend operator < (SRN x,SRN y){
        int t = max(x.b,y.b);
        x.v <<= (t-x.b), y.v <<= (t-y.b);
        return x.s*x.v < y.s*y.v;
    }
    /*
    bool friend operator == (SRN x,SRN y){
        return x.s==y.s&&x.v==y.v&&x.b==y.b;
    }
    void read(){
        scanf("%d/%d",&v,&b);
        s = v<0?-1:v>0, v *= s;
        b = __builtin_popcount(b-1);
    }
    void print(){
        if(s==-1) cout<<'-';
        cout<<v<<'/'<<(1<<b)<<endl;
    }
    */
};
//取两数之间最上方的数中最靠近0的数
SRN merge(SRN x,SRN y){
    if(x.s*y.s<0) return SRN(0,0,0);
    int t = max(x.b,y.b) + 1;
    x.v <<= (t-x.b), y.v <<= (t-y.b);
    if(x.v>y.v) swap(x,y);
    x.b = t, x.s = y.s;
    if(x.b==1&&y.v-x.v>2) return SRN(x.s,x.v/2+1,0);
    for(int i=30;i>=0;i--){
        if((((x.v>>i)+1)<<i)<y.v){
            x.v = ((x.v>>i)+1)<<i;
            break;
        }
    }
    while(x.b&&!(x.v&1)) x.v >>= 1, x.b--;
    return x;
}
//array to mask
int a2m(int a[3][3]){
    int m = 0;
    for(int i=0;i<3;i++) for(int j=0;j<3;j++) m = m * 3 + a[i][j];
    return m;
}
//mask to array
void m2a(int m,int a[3][3]){
    for(int i=2;i>=0;i--) for(int j=2;j>=0;j--) a[i][j] = m % 3, m /= 3;
}
//读棋盘
int read(){
    char s[3][5];
    for(int i=0;i<3;i++) scanf("%s",s[i]);
    int a[3][3] = {0};
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(s[i][j*2]=='O') a[i][j] = 1;
            if(s[i][j*2]=='X') a[i][j] = 2;
        }
    }
    return a2m(a);
}
//求从当前状态左玩家操作能转移到的所有状态
vector<int> getL(int m){
    int a[3][3]; m2a(m,a);
    vector<int> L;
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(a[i][j]!=1) continue;
            int i1=max(i-1,0),i2=min(i+1,2),j1=max(j-1,0),j2=min(j+1,2);
            int b[3][3];
            memcpy(b,a,sizeof(a));
            b[i][j] = 0, b[i1][j] = 0, b[i2][j] = 0;
            L.push_back(a2m(b));
            memcpy(b,a,sizeof(a));
            b[i][j] = 0, b[i][j1] = 0, b[i][j2] = 0;
            L.push_back(a2m(b));
            memcpy(b,a,sizeof(a));
            b[i][j] = 0, b[i1][j] = 0, b[i2][j] = 0;
            b[i][j] = 0, b[i][j1] = 0, b[i][j2] = 0;
            L.push_back(a2m(b));
        }
    }
    return L;
}
//求从当前状态右玩家操作能转移到的所有状态
vector<int> getR(int m){
    int a[3][3]; m2a(m,a);
    vector<int> R;
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            if(a[i][j]!=2) continue;
            int b[3][3];
            memcpy(b,a,sizeof(a));
            b[i][j] = 0;
            R.push_back(a2m(b));
        }
    }
    return R;
}
const int N = 2e5;
int vis[N];
SRN f[N];
SRN calc(int x){
    if(vis[x]) return f[x];
    vis[x] = 1;
    vector<int> L = getL(x);
    vector<int> R = getR(x);
    //求左集最大值和右集最小值
    SRN Lmax = SRN(-1,N,0), Rmin = SRN(1,N,0);
    for(int l:L) if(Lmax<calc(l)) Lmax = calc(l);
    for(int r:R) if(calc(r)<Rmin) Rmin = calc(r);
    return f[x] = merge(Lmax,Rmin);
}
int main(){
    int T; scanf("%d",&T);
    while(T--){
        int n; scanf("%d",&n);
        SRN ans(0,0,0);
        while(n--) ans = ans + calc(read());
        if(ans.s==1) puts("Alice");
        if(ans.s==0) puts("Second");
        if(ans.s==-1) puts("Bob");
    }
}

```

### 最小圆覆盖

```cpp
Point get_c(Point a,Point b,Point c)
{
    Point p=(a+b)/2;    //ad中点
    Point q=(a+c)/2;    //ac中点
    Point v1=b-a;
    Point v(v1.y,-v1.x);
    Point w1=c-a;
    Point w(w1.y,-w1.x);  //中垂线的方向向量

    if (dcmp(Length(Cross(v,w)))==0)    //平行
    {
        if (dcmp(Length(a-b)+Length(b-c)-Length(a-c))==0)
           return (a+c)/2;
        if (dcmp(Length(b-a)+Length(a-c)-Length(b-c))==0)
           return (b+c)/2;
        if (dcmp(Length(a-c)+Length(c-b)-Length(a-b))==0)
           return (a+b)/2;
    }
    return GetlineIntersection(p,v,q,w);
}

double r;
Point min_circular(Point P[],int n)
{
    random_shuffle(P+1,P+n+1);    //随机化
    Point c=P[1];
    r=0;
    //c 圆心
    //r 半径
    for (int i=2;i<=n;i++)
        if (dcmp(Length(c-P[i])-r)>0)    //不在圆内
        {
            c=P[i],r=0;
            for (int j=1;j<i;j++)
                if (dcmp(Length(c-P[j])-r)>0)
                {
                    c=(P[i]+P[j])/2.0;
                    r=Length(c-P[i]);
                    for (int k=1;k<j;k++)
                        if (dcmp(Length(c-P[k])-r)>0)
                        {
                            c=get_c(P[i],P[j],P[k]);
                            r=Length(c-P[i]);
                        }
                }
        }
    return c;
}
```

### 圆的面积并

```cpp
struct Point{
    double x,y;
    double ang;
    int d;
    Point(double x=0,double y=0):x(x),y(y){}
    Point(double _x,double _y,double _ang,int _d){
        x = _x;
        y = _y;
        ang = _ang;
        d = _d;
    }
};
struct Circle{
    Point c;
    double r;
    int d;
    Circle(){};
    Circle(Point c,double r=0):c(c),r(r){}
    Point point(double a){
        return Point(c.x+cos(a)*r,c.y+sin(a)*r);
    }
    bool contain (const Circle & cir)const{ return dcmp(Length(cir.c-c)+cir.r-r)<=0;}
    bool interect (const Circle & cir)const{ return dcmp(Length(cir.c-c)-cir.r-r)<0;}
};

bool circmp(const Circle& u, const Circle& v)
{
    return dcmp(u.r - v.r) < 0;
}
bool cmp(const Point& u, const Point& v)
{
    if (dcmp(u.ang - v.ang)) return u.ang < v.ang;
    return u.d > v.d;
}
double calc(Circle cir, Point p1, Point p2)
{
    double ans = (p2.ang - p1.ang) * sqr(cir.r)
         - Cross ( (p1-cir.c),(p2-cir.c)) + Cross( p1,p2);
    return ans *0.5;
}
Point tp[10000];
double area[10000];
void CirUnion(Circle cir[], int n)
{
    Circle cir1, cir2;
    sort(cir, cir + n, circmp);
    for (int i = 0; i < n; ++i)
        for (int j = i + 1; j < n; ++j)
        if (cir[j].contain(cir[i]))
                cir[i].d++;
    for (int i = 0; i < n; ++i)
    {
        int tn = 0, cnt = 0;
        for (int j = 0; j < n; ++j)
        {
            if (i == j) continue;
            vector<Point> p;
            if (getCircleCircleIntersection(cir[i],cir[j],p) < 2) continue;
            p[0].ang = angle(p[0]-cir[i].c);
            p[1].ang = angle(p[1]-cir[i].c);
            p[0].d = 1;
            tp[tn++] = p[0];
            p[1].d = -1;
            tp[tn++] = p[1];
            if (dcmp(p[0].ang - p[1].ang) > 0) cnt++;
        }
        tp[tn++] = Point(cir[i].c.x - cir[i].r, cir[i].c.y, PI, -cnt);
        tp[tn++] = Point(cir[i].c.x - cir[i].r, cir[i].c.y, -PI, cnt);
        sort(tp, tp + tn, cmp);
        int pp, s = cir[i].d + tp[0].d;
        for (int j = 1; j < tn; ++j)
        {
            pp = s;
            s += tp[j].d;
            area[pp] += calc(cir[i], tp[j - 1], tp[j]);
        }
    }
}

Circle c[1050];
int n;
double s[2000];
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%lf %lf %lf",&c[i].c.x,&c[i].c.y,&c[i].r);
        c[i].d=1;
    }
    CirUnion(c,n);
    for (int i = 1; i <= n; ++i)
    {
        area[i] -= area[i + 1];
    }
    for ( int i = 1 ; i <= n ; i++) printf("[%d] = %.3f\n",i,area[i]+eps);
    return 0;
}
```

### 多边形面积并

```cpp
#include <bits/stdc++.h>

using namespace std;


#define MP make_pair
int n;
pair<double, int> c[10000];
vector<Point> p[600];
double segP( Point p1, Point p2, Point p3 )
{
	if( dcmp(p2.x-p3.x) )
		return (p1.x-p2.x)/(p3.x-p2.x);
	else
		return (p1.y-p2.y)/(p3.y-p2.y);
}
double polyUnion()
{
	int i, j, ii, jj, ta, tb, r, d;
	double z, w, s, sum, tc, td;
	Point tmp1, tmp2;
	sum = 0;
	for( i = 0; i < n; ++i )	for( ii = 0; ii < p[i].size()-1; ++ii )
	{
		r = 0;
		c[r++] = make_pair(0., 0);
		c[r++] = make_pair(1., 0);
		for( j = 0; j < n; ++j )	if( i-j )
			for( jj = 0; jj < p[j].size()-1; ++jj ){
				ta = dcmp( Cross(p[i][ii+1]-p[i][ii], p[j][jj]-p[i][ii]) );
				tb = dcmp( Cross(p[i][ii+1]-p[i][ii], p[j][jj+1]-p[i][ii]) );
				if( !ta && !tb ){
					tmp1.x = p[j][jj+1].x-p[j][jj].x;
					tmp1.y = p[j][jj+1].y-p[j][jj].y;
					tmp2.x = p[i][ii+1].x-p[i][ii].x;
					tmp2.y = p[i][ii+1].y-p[i][ii].y;
					if( dcmp( Dot(tmp1, tmp2) ) > 0 && j < i ){
						c[r++] = MP( segP(p[j][jj], p[i][ii], p[i][ii+1]), 1 );
						c[r++] = MP( segP(p[j][jj+1], p[i][ii], p[i][ii+1]), -1 );
					}
				}
				else if( ta >= 0 && tb < 0 ){
					tc = Cross(p[j][jj+1]-p[j][jj], p[i][ii]-p[j][jj]);
					td = Cross(p[j][jj+1]-p[j][jj], p[i][ii+1]-p[j][jj]);
					c[r++] = MP(tc/(tc-td), 1);
				}
				else if( ta < 0 && tb >= 0 ){
					tc = Cross(p[j][jj+1]-p[j][jj], p[i][ii]-p[j][jj]);
					td = Cross(p[j][jj+1]-p[j][jj], p[i][ii+1]-p[j][jj]);
					c[r++] = MP(tc/(tc-td), -1);
				}
			}
		sort(c, c+r);
		z = min(max(c[0].first, 0.), 1.);
		d = c[0].second;
		s = 0;
		for( j = 1; j < r; ++j ){
			w = min(max(c[j].first, 0.), 1.);
			if( !d ) s += w-z;
			d += c[j].second;
			z = w;
		}
		tmp1.x = tmp1.y = 0;
		sum += Cross(p[i][ii], p[i][ii+1])*s;
	}
	return 0.5*sum;
}

int main()
{
	int i, j;
	double area, tmp;
    Point k;
	while( scanf("%d", &n) != EOF )
	{
		area = 0;
		for( i = 0; i < n; ++i )
		{
			for( j = 0; j < 4; ++j ){
                scanf("%lf %lf", &k.x, &k.y);
                p[i].push_back(k);
			}
			p[i].push_back(p[i][0]);

			tmp = 0;
			for( j = 1; j <= 4; ++j )
				tmp += p[i][j-1].x*p[i][j].y - p[i][j-1].y*p[i][j].x;
			area += fabs(tmp);

			if( dcmp(tmp) < 0 )	swap(p[i][1], p[i][3]);
		}
        double z=polyUnion();
		printf("%.10f\n", 0.5*area/z);
	}

	return 0;
}

```

### 平面最近点对

```cpp
const int INF=0x7fffffff;

bool cmp(const Point &a,const Point &b){
   if(a.x==b.x){
      return a.y<b.y;
   }
   return a.x<b.x;
}
bool cmq(const int &a,const int &b){return p[a].y<p[b].y;}

inline double mg(int l,int r)
{
    double d=INF;
    if(l==r) return d;
    if(l+1==r) return Length(p[l]-p[r]);
    int mid=(l+r)>>1;
    double pa=mg(l,mid);
    double pb=mg(mid+1,r);
    d=min(pa,pb);
    cnt=0;
    for(int i=l;i<=r;i++){
        if(fabs(p[i].x-p[mid].x)<d){//<=
           in[++cnt]=i;
        }
    }
    sort(in+1,in+cnt+1,cmq);
    for(int i=1;i<=cnt;i++){
        for(int j=i+1;j<=cnt && p[in[j]].y-p[in[i]].y<d;j++){
            double now=Length(p[in[i]]-p[in[j]]);
            d=min(now,d);
        }
    }
    return d;
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%lf %lf",&p[i].x,&p[i].y);
    }
    sort(p+1,p+n+1,cmp);
    printf("%.4f\n",mg(1,n));
    return 0;
}
```

