[TOC]



## 最小公倍数

```c++
int gcd(int a,int b)
{
    return b==0? a:gcd(b,a%b);
}
```





## 拓展欧几里得求线性方程

```c++
/*
拓展欧几里得算法 (a,b非零)
求解ax+by=gcd(a,b)的一个解(x1,y1)
则通解为(x1+k*b/g,y1-k*a/g)

如果求解ax+by=c
输入a,b后 下面模板会求出
ax+by=+\-gcd(a,b)的一个解(x1,y1)
正负号虽然不确定（和扩欧写法有关） 但等式是成立的
ax+by=c 的一个解为(x2,y2)=c/g*(x1,y1)
则通解为(x2+k*b/g,y2-k*a/g)
*/
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

ll e_gcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0){
        x=1;
        y=0;
        return a;
    }
    ll ans=e_gcd(b,a%b,x,y);
    ll temp=x;
    x=y;
    y=temp-a/b*y;
    return ans;
}

int main()
{
    ios::sync_with_stdio(false);
    ll a,b,c,x,y;
    cin>>a>>b>>c;
    ll gcd=e_gcd(a,b,x,y);
    if(c%gcd!=0) cout<<"无解"<<endl;
    else{
        x=c/gcd*x;
        cout<<"x的一个解为: "<<x<<endl;
        ll bei=abs(b/gcd);
        cout<<"x的最小正整数解"<<(x%bei+bei)%bei<<endl;
    }
    return 0;
}

```













## Miller-Rabin素数判定

设$n$是奇素数，记$n-1=2^kq$，$q$是奇数，对不被$n$整除的某个$a$，如果下述**两个条件都成立**，则$n$一定是合数：（但有不成立的也不一定是素数）

- $a^q \not\equiv 1 \ (mod \ n)$
- 对所有的$i=0,1,2,...,k-1 ,\quad a^{2^iq}\not\equiv -1\ (mod \ n)$

和费马小定理测试相比，$miller\_rabin$测试不存在“卡米歇尔型数”，因为可以保证，如果$n$是奇合数，则1~n-1之间至少有75%的数可作为$miller\_rabin$的证据。即这些数作为$a$时，可以说明其合数性。

**换句话说，每个合数都有许多证据来说明它的合数性。**

例如随机选取$a$的100个值，若其中没有$n$的$miller\_rabin$证据，则$n$是合数的概率小于$0.25^{100}$，即认为是素数



**时间复杂度**  $O(log^2n)$



**注意看要不要使用$unsigned \ long \ long$**  

```c++
//O(lognlogn) miller_rabin素性测试
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

ll mod_mul(ll a,ll b,ll c){//a*b %c 乘法改加法 防止超long long
    ll res=0;
    a=a%c;
    while(b)
    {
        if(b&1) res=(res+a)%c;
        b>>=1;
        a=(a+a)%c;
    }
    return res;
}

ll fast_exp(ll a,ll b,ll c){
    ll res=1;
    a=a%c;
    while(b)
    {
        if(b&1) res=mod_mul(res,a,c);
        b>>=1;
        a=mod_mul(a,a,c);
    }
    return res;
}
//
//ll fast_exp(ll a,ll b,ll c){//a^b %c
//    ll res=1;
//    a=a%c;
//    while(b>0)
//    {
//        if(b&1) res=(a*res)%c;
//        b>>=1;
//        a=(a*a)%c;
//    }
//    return res;
//}

bool test(ll n,ll a,ll d)
{//d=n-1
    if(!(n&1)) return false;
    while(!(d&1))  d>>=1;//将d分解为奇数 至少有一个2因子，所以d!=n-1
    ll t=fast_exp(a,d,n);
    while(d!=n-1 && t!=1 && t!=n-1){
        t=mod_mul(t,t,n);
        d<<=1;
    }
    return ((t==n-1) || (d&1) ==1 );//两个条件都不成立则一定是合数; 若两个有一个成立，且多次，对于合数来说，可能性极小，所以可以认为是素数
}

bool is_prime(ll n){
    if(n<2) return false;
    if(n==2) return true;
    ll a[30];
    srand(time(0));
    for(int i=0;i<7;++i) {//测试7次
        a[i]=rand()%(n-2)+2;//取[2,n-1]随机数
        if(!test(n,a[i],n-1)) return false;//找到证据说明是合数
    }
    return true;//如果上面所有测试都是true
}

int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        ll a;
        cin>>a;
        cout<<(is_prime(a) ? "Yes": "No")<<endl;
    }
    return 0;
}
```



## Pollard_Rho质因数分解





```c++
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<time.h>
#include<iostream>
#include<algorithm>
using namespace std;


//****************************************************************
// Miller_Rabin 算法进行素数测试
//速度快，而且可以判断 <2^63的数
//****************************************************************
const int S=20;//随机算法判定次数，S越大，判错概率越小


//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的
//  a,b,c <2^63
long long mult_mod(long long a,long long b,long long c)
{
    a%=c;
    b%=c;
    long long ret=0;
    while(b)
    {
        if(b&1){ret+=a;ret%=c;}
        a<<=1;
        if(a>=c)a%=c;
        b>>=1;
    }
    return ret;
}



//计算  x^n %c
long long pow_mod(long long x,long long n,long long mod)//x^n%c
{
    if(n==1)return x%mod;
    x%=mod;
    long long tmp=x;
    long long ret=1;
    while(n)
    {
        if(n&1) ret=mult_mod(ret,tmp,mod);
        tmp=mult_mod(tmp,tmp,mod);
        n>>=1;
    }
    return ret;
}





//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数
//一定是合数返回true,不一定返回false
bool check(long long a,long long n,long long x,long long t)
{
    long long ret=pow_mod(a,x,n);
    long long last=ret;
    for(int i=1;i<=t;i++)
    {
        ret=mult_mod(ret,ret,n);
        if(ret==1&&last!=1&&last!=n-1) return true;//合数
        last=ret;
    }
    if(ret!=1) return true;
    return false;
}

// Miller_Rabin()算法素数判定
//是素数返回true.(可能是伪素数，但概率极小)
//合数返回false;

bool Miller_Rabin(long long n)
{
    if(n<2)return false;
    if(n==2)return true;
    if((n&1)==0) return false;//偶数
    long long x=n-1;
    long long t=0;
    while((x&1)==0){x>>=1;t++;}
    for(int i=0;i<S;i++)
    {
        long long a=rand()%(n-1)+1;//rand()需要stdlib.h头文件
        if(check(a,n,x,t))
            return false;//合数
    }
    return true;
}


//************************************************
//pollard_rho 算法进行质因数分解
//************************************************
long long factor[100];//质因数分解结果（刚返回时是无序的）
int tol;//质因数的个数。数组小标从0开始

long long gcd(long long a,long long b)
{
    if(a==0)return 1;//???????
    if(a<0) return gcd(-a,b);
    while(b)
    {
        long long t=a%b;
        a=b;
        b=t;
    }
    return a;
}

long long Pollard_rho(long long x,long long c)
{
    long long i=1,k=2;
    long long x0=rand()%x;
    long long y=x0;
    while(1)
    {
        i++;
        x0=(mult_mod(x0,x0,x)+c)%x;
        long long d=gcd(y-x0,x);
        if(d!=1&&d!=x) return d;
        if(y==x0) return x;
        if(i==k){y=x0;k+=k;}
    }
}
//对n进行素因子分解
void findfac(long long n)
{
    if(Miller_Rabin(n))//素数
    {
        factor[tol++]=n;
        return;
    }
    long long p=n;
    while(p>=n)p=Pollard_rho(p,rand()%(n-1)+1);
    findfac(p);
    findfac(n/p);
}

int main()
{
    //srand(time(NULL));//需要time.h头文件//POJ上G++不能加这句话
    long long n;
    while(scanf("%I64d",&n)!=EOF)
    {
        tol=0;
        findfac(n);
        for(int i=0;i<tol;i++)printf("%I64d ",factor[i]);
        printf("\n");
        if(Miller_Rabin(n))printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```

## 卡米歇尔数

* **卡米歇尔数都是奇数**
* **卡米歇尔数是不同素数的乘积（幂次为1）**



**卡米歇尔数的考塞特判别法**   

设n是合数，则n是卡米歇尔数当且仅当它是**奇数**，且整除n的每个素数$p$满足下述两个条件：

- $p^2 $不整除n
- $p-1$整除$n-1$  （实际上也整除$\frac{n}{p}-1$）



**时间复杂度**  筛选出区间里的卡米歇尔数可以认为是$大常数*O(n)$的，$n$是区间长度



```c++
//常数*O(n)
//也可做大区间
//欧拉线性筛求出最小质因子
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int maxn=1e8+10;

bool valid[maxn];
int ans[maxn/10];
int res[maxn];//每个数的最小质因子

void getprime(int n,int &tot)
{
    tot=0;
    memset(valid,true,sizeof(valid));
    for(int i=2;i<=n;++i){
        if(valid[i]){
            tot++;
            ans[tot]=i;
            res[i]=i;
        }
        for(int j=1;(j<=tot) && (i*ans[j]<=n);++j){
            int tp=i*ans[j];
            valid[tp]=false;
            res[tp]=ans[j];//记录每个数的最小质因子
            if(i%ans[j]==0) break;
        }
    }
}

bool check(int x)
{
    if (x%2==0) return false;
    if (valid[x]) return false;
    //对x进行分解 要求每个素因子的指数均为1且p-1 | x-1
    int tp=x;
    while(tp!=1)//是合数
    {
        int minp=res[tp];
        if((x-1)%(minp-1)) return false;
        tp=tp/minp;
        if(tp%minp==0) return false;//p指数>1
    }
    return true;
}

vector<int> carmichael;

int main()
{
    int tot;
    getprime(1e8,tot);
    cout<<tot<<endl;
    cout<<clock()<<"ms"<<endl;
    for(int i=2;i<=1e8;++i) if(check(i)) carmichael.push_back(i);
    for(auto k:carmichael) cout<<k<<endl;
    cout<<carmichael.size()<<"个"<<endl;
    cout<<clock()<<"ms"<<endl;
    return 0;
}

```

## 原根

定义$a$模$p$的**阶**指$e_p(a)=[使得a^e\equiv 1(mod \ p)的最小e]$

**次数整除性质**  设a是不被素数$p$整除的整数，假设$a^n \equiv 1 \ (mod \ p)$，则次数$e_p(a)$整除$n$，特别地$e_p(a)$总整除$p-1$

而$e_p(a)=p-1$的数称为原根。

原根的$1\sim (p-1)$次幂模$p$取遍$[1,p-1]$这$p-1$个数。**（竞赛中为了方便通常取$0\sim (p-2)$次幂）**

**推论**  $p$是素数，且$d|p−1$，那么模$p$的阶为$d$且不同余的整数个数为$\varphi(d)$

**原根定理**  每个素数$p$都有原根。更精确地，有恰好$\varphi(\varphi(p))=\varphi(p-1)$个模$p$的原根。

---



求一个$mod \ p$意义下的原根（$p$为素数）

由于原根的分布比较广，并且最小的原根通常也较小，故可以枚举可能的数来求原根。

对于一个待检查的$p$，对$p-1$的每一个素因子$a$，检查$g^{\frac{p-1}{a}}\equiv 1 \ (mod \ p)$ 是否成立，如果有成立的则说明$g$不是原根**(即还没到$p-1$，模$p$的结果就为$1$了)**。否则$g$为原根。



另外要注意的是，不仅素数有原根，$p^k,2*p^k$也有原根  （充要条件）

这时，要将$p-1$换为$\varphi(p)$  这里$p$可以是非素数



**时间复杂度**  对于单个$p$，质因子分解的时间   ；对于区间问题，可以做到$O(nlogn)$



```c++
//求一个数的原根
//时间复杂度O(sqrt(n))
//区间可以做到O(nlogn)
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

vector<ll> a;//p-1的所有质因子

ll fast_pow(ll a,ll b,ll c){
    ll res=1;
    a=a%c;
    while(b)
    {
        if(b&1) res=(res*a)%c;
        b=b>>1;
        a=(a*a)%c;
    }
    return res;
}

bool g_test(ll g,ll p){
    for(ll i=0;i<a.size();++i)
        if(fast_pow(g,(p-1)/a[i],p)==1)//非素数时，要将p-1换为\varphi(p)
            return 0;
    return 1;
}

ll primitive_root(ll p)
{
    a.clear();
    ll tmp=p-1;//非素数时，要将p-1换为\varphi(p)
    for(ll i=2;i<=tmp/i;++i)
        if(tmp%i==0){
            a.push_back(i);
            while(tmp%i==0) tmp/=i;
        }
    if(tmp!=1) a.push_back(tmp);
    long long g=1;
    while(1)
    {
        if(g_test(g,p)) return g;
        ++g;
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cout<<primitive_root(1e9+9)<<endl;
    return 0;
}
```





**例题1**  

![img](https://s1.ax2x.com/2018/08/17/59jAsN.png) 

$1\le r,a_1,a_2,...,a_n< 2017$     **（这样保证了每个数都有对应的指数）**

使用原根可以将乘法变为加法，问题变为有多少个子集的**对应指数和**模$(2017-1)$等于$r$对应的指数，由于结果只需要奇偶性，$bitset$经典题，异或即可。

另外，**题目规定空集合的乘积认为是1**。这样可以将1对应的指数（即$2016\%(2017-1)=0$，对应$bitset$中的0)初始化为$true$

```c++
#include<bits/stdc++.h>
using namespace std;

const int mod=2017;

bitset<mod-1> f;
int p[mod+10];

int main()
{
    //5是2017的原根
    freopen("in.txt","r",stdin);
    int g=1;
    for(int i=0;i<mod-1;++i){
        p[g]=i;
        g=g*5%mod;
    }
    int n,a,k;
    cin>>n>>k;
    bool flag=0;
    f[p[1]]=1;//空集的乘积为1 对应指数p[1]设为true
    for(int i=0;i<n;++i){
        cin>>a;
        if(p[a]==0){//即a=1 显然这样会使答案为偶数  因为*1结果不变 集合数*2
            flag=true;break;
        }
        //循环左移
        f ^= (f<<p[a] | f>>(mod-1-p[a]) );//对应的指数
    }
    if(flag) cout<<0<<endl;
    else cout<<f[p[k]]<<endl;
    return 0;
}
```





**例题2**

![img](https://s1.ax2x.com/2018/08/20/59haxG.png)

**乘法看起来没法搞，考虑原根即求有多少个二元组$(i,j)$满足$i+j$模$p-1$等于$k$**

**$i,j,k$为$a_i,a_j,a_k$对应的原根。$FFT$即可。**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef complex<double> xu;
int debug_num=0;
#define debug cout<<"debug "<<++debug_num<<" :"
const double pi=acos(-1.0);
const int maxn=2e5+10;

vector<ll> aa;//p-1的所有质因子

ll fast_pow(ll a,ll b,ll c){
    ll res=1;
    a=a%c;
    while(b)
    {
        if(b&1) res=(res*a)%c;
        b=b>>1;
        a=(a*a)%c;
    }
    return res;
}

bool g_test(ll g,ll p){
    for(ll i=0;i<aa.size();++i)
        if(fast_pow(g,(p-1)/aa[i],p)==1)//非素数时，要将p-1换为\varphi(p)
            return 0;
    return 1;
}

ll primitive_root(ll p)
{
    aa.clear();
    ll tmp=p-1;//非素数时，要将p-1换为\varphi(p)
    for(ll i=2;i<=tmp/i;++i)
        if(tmp%i==0){
            aa.push_back(i);
            while(tmp%i==0) tmp/=i;
        }
    if(tmp!=1) aa.push_back(tmp);
    long long g=1;
    while(1)
    {
        if(g_test(g,p)) return g;
        ++g;
    }
}

xu omega[maxn<<2],omegaInverse[maxn<<2];//辅助

void init(const int n){
    for(int i=0;i<n;++i){
        omega[i]=xu(cos(2*pi/n*i),sin(2*pi/n*i));
        omegaInverse[i]=conj(omega[i]);
    }
}

void trans(xu *a,const int n,const xu *omega){//a是系数  n是2的次幂  omega是要带入的点
    int k=0;
    while((1<<k)<n) k++;
    //看N是2的多少次幂
    for(int i=0;i<n;++i){
        int t=0;
        for(int j=0;j<k;++j) if(i&(1<<j)) t|=(1<<(k-j-1));
        if(i<t) swap(a[i],a[t]);//原地翻转
    }
    for(int l=2;l<=n;l*=2){//l=1不用求 就是系数
        int m=l/2;
        for(xu *p=a;p!=a+n;p+=l){//l为一段要求 由两段l/2合并得到
            //当前处理[p,p+l)
            for(int i=0;i<m;++i){
                //蝴蝶操作  omega_{l}^{i}=omega_{N}^{N/l*i}
                xu t=omega[n/l*i]*p[i+m];
                p[i+m]=p[i]-t;
                p[i]+=t;
            }
        }
    }
}

void dft(xu *a,const int n){
    trans(a,n,omega);
}

void idft(xu *a,const int n){
    trans(a,n,omegaInverse);
    for(int i=0;i<n;++i) a[i]/=n;
}

xu a[maxn<<2];
xu b[maxn<<2];
int g[maxn];//对应指数
int c[maxn];//系数
int d[maxn];//数
ll ans[maxn];//每个指数对应的答案

int main()
{
#ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
#endif
    ios::sync_with_stdio(false);
    int n,p,num_0;
    num_0=0;
    cin>>n>>p;
    int root=primitive_root(p);
    int tp=1;
    for(int i=0;i<p-1;++i){
        g[tp]=i;
        tp=tp*root%p;
    }
    for(int i=1;i<=n;++i){
        cin>>d[i];
        if(d[i]%p){
            c[g[d[i]%p]]++;
        }
        else num_0++;
    }
    for(int i=0;i<p-1;++i){//p-1项
        a[i]=xu(c[i],0);
        b[i]=a[i];
    }
    int N=1;
    while(N<2*(p-1)-1) N<<=1;//fft技巧:    总项数>=(多项式项数之和-1) 且是2的次幂
    init(N);
    dft(a,N);
    dft(b,N);
    for(int i=0;i<N;++i) a[i]*=b[i];
    idft(a,N);
    for(int i=0;i<2*(p-1)-1;++i){
        ans[i%(p-1)]+=(ll)(a[i].real()+0.5);//注意是模p-1
    }
    ll ans_0=1LL*num_0*num_0+2LL*num_0*(n-num_0);
    for(int i=1;i<=n;++i){
        if(d[i]>=p) cout<<0<<endl;
        else if(d[i]==0) cout<<ans_0<<endl;
        else{
            cout<<ans[g[d[i]]]<<endl;
        }
    }
    return 0;
}

```

## 质因数分解

 $O(\sqrt{n})$   

**注意**  若时间稍紧 先筛选下素数  时间复杂度$O(\frac{\sqrt{n}}{log\sqrt{n}})$    

```c++
//O(sqrt n)
#include<bits/stdc++.h>
using namespace std;

const int maxn=100;

int a[maxn];//质因子
int b[maxn];//质因子的指数
int tot;//1~tot

void factor(int n)
{
    int now=n;
    tot=0;
    for(int i=2;i*i<=now;++i) if(now%i==0){//时间稍紧后使用素数ans[i]代替i
        a[++tot]=i;
        b[tot]=0;
        while(now%i==0){
            ++b[tot];
            now/=i;
        }
    }
    if(now>1){//一个合数n必定有小于等于sqrt{n} 的质因子   将其全部除尽后 若不为1 则为大于sqrt{n}的质因子 且仅有一个
        a[++tot]=now;
        b[tot]=1;
    }
}

int main()
{
    int n;
    cin>>n;
    factor(n);//n>1
    for(int i=1;i<=tot;++i){
        if(i==tot) cout<<a[i]<<'^'<<b[i]<<endl;
        else cout<<a[i]<<'^'<<b[i]<<" * ";
    }
    return 0;
}


```





## 素数筛法 O(nlogn)

一个合数n必定有小于等于$\sqrt{n}$ 的质因子  

```c++
//素数筛法  O(nlogn)
#include<bits/stdc++.h>
using namespace std;

const int maxn=1e7+10;

bool valid[maxn];
int ans[maxn];//存素数

void getprime(int n,int &tot,int ans[])
{
    tot=0;
    for(int i=2;i<=n;++i) valid[i]=true;
    for(int i=2;i<=n;++i){
        if(valid[i]){
            if(n/i<i) break;//防止下面爆int 
            //一个合数n必定有小于等于根号n的质因子
            for(int j=i*i;j<=n;j+=i) valid[j]=false;
        }
    }
    for(int i=2;i<=n;++i) if(valid[i]) ans[tot++]=i;
}
//考虑这里
//为什么是j=i*i
//对于2i 3i 4i  (i-1)i  显然其不是质数
//那么他们之前一定被筛去过了吗？
//是的 因为2 3 4 ... i-1在前面不是枚举过了吗,2i 3i 4i  (i-1)i是他们的i倍 所以会被筛去
//不对 不是只有素数被枚举的吗?
//是的 但是不是素数的数 比如j   则j=k*i  i是素数   即i能筛去j  和j的倍数
//那i貌似没有被筛去？
//i要是合数 自然会被筛去啦
//这里既然能进入循环 就说明在2~i-1中没有哪个数能筛去它
//所以就让他筛别人了
//有点道理 我想想能不能继续优化
//想到了 这...会重复筛啊
//举个例子？
//就是辣些质数的稍微大一些的公倍数哇
//比如12  当i=2时(从4开始)会筛12;当i=3时(从9开始)还会筛12
//这...血崩

int main()
{
    int Count;//素数个数
    getprime(1e3,Count,ans);
    cout<<Count<<endl;
    return 0;
}
```

 



## 素数筛法 O(n) 欧拉线性筛

```c++
//素数筛法 O(n)
#include<bits/stdc++.h>
using namespace std;

const int maxn=1e6+10;

bool valid[maxn];
int ans[maxn];

void getprime(int n,int &tot,int ans[])
{
    tot=0;
    memset(valid,true,sizeof(valid));
    for(int i=2;i<=n;++i){
        if(valid[i]){
            tot++;
            ans[tot]=i;
        }
        //下面的主角是小于等于i的每个质数
        for(int j=1;(j<=tot) && (i*ans[j]<=n);++j){
            valid[i*ans[j]]=false;
            if(i%ans[j]==0) break;//如果整除就break;
        }
    }
}
//时间复杂度是O(n)的
//因为每个数只被筛去一次
//为什么
//首先其还是筛选法 考虑用什么筛的
//对于每个i 乘以小于i的每个素数 直到能整除就停止
//这样能保证每个数只被筛去一次
//为什么

//首先
//对于1~n我们都枚举了一遍是吧(对于连循环都不能进的i，自然它不能筛别人)
//如果对于每个i 我都拿小于i的所有素数乘以i去筛 即没有break
//这样所有合数一定都能被筛去
//但是时间是n^2/ln n 的
//血崩 因为有太多重复了
//考虑为什么重复
//比如i=6  取质数3 筛去了18  i=9 取质数2 也筛去了18
//比如i=6  取质数5 筛去了30  i=10 取质数3 筛去了30 i=15 取质数2 筛去了30
//如果加上break
//筛去18的是9*2
//筛去30的是15*2
//为什么18不会被6*3删去？ 因为6%2=0 提前break了， 因为若有一个素数p|i,则我用i和后面更大的素数去筛选，不如用p和更大的i去筛选，即保证了筛掉每个数的是其最小质因子
//****当我发现当前的i能整除一个素数(比如2 | 6)  那我有理由相信2会在之后和其他i组合删去 6和2后面质数组合能删去的所有合数****
//比如这里2*9 就删去了 3*6
//同样对于30  删去它的一定是2*15  而3*10=2*3*10/2 ; 5*6=2*5*6/2
//****即每个合数都会被它所有质因数中最小的质数*i删去****
//怎么说明每个数只会被删去一次呢？
//因为这里每个数只会被一个质数*i删去
//又是从小到大枚举的质数
//这可以反过来想
//比如一个数a=p*q*r  其中p,q,r是质数 且从小到大排列
//则在这个算法中筛去a的一定是p*(i=q*r)
//因为q要想筛去a  则i是p*r   这显然不可能
//因为q是比p大的 当到p时 p|p*r 则会break 轮不到q
//综上即为线性筛算法的口语证明


int main()
{
    int Count;//素数个数
    getprime(1e6,Count,ans);
    cout<<Count<<endl;
    return 0;
}


```





## 区间数的最大质因子(基于埃筛)

```c++
 //筛法求 1~n 内数的最大质因数  O(nlogn)
#include<iostream>
using namespace std;

const int maxn=2e5+10;

int ans[maxn];//数的最大质因子 素数就是自己

void get_prime(int n)
{
    for(int i=2;i<=n;++i) ans[i]=i;
    for(int i=2;i<=n;++i){
        if(ans[i]==i){//素数
            for(int j=i*2;j<=n;j+=i)//最后筛去的即为最大质因子
                ans[j]=i;
        }
    }
}

int main()
{
    get_prime(2e5);//1没有质因子
    for(int i=2;i<=1000;++i){
        cout<<i<<' '<<ans[i]<<"   ";
    }
    return 0;
}

```





## 区间质因数分解(基于埃筛)

先$O(nlogn)$求出每个数的所有质因子（**实际上没必要所有，到根号n就行**）  

再$O(nlogn)$直接除求出质因子对应的指数

```c++
//注意多个vector push速度很慢
//若无需记录 尽量不用vector
#include<bits/stdc++.h>
using namespace std;

const int maxn=1e6+10;

vector<int> ans[maxn];//质因子
vector<int> bns[maxn];//对应指数

//先预处理每个数有哪些质因数
void init1(int n)//处理1000005个数本机跑了1.303s 评测机0.4s左右
{
    for(int i=2;i<=n;++i){
        if(ans[i].size()==0){
            for(int j=i;j<=n;j+=i){
                ans[j].push_back(i);
            }
        }
    }
}

void init2(int n)
{
    for(int i=2;i<=n;++i){
        int tp=i;
        for(int j=0;j<ans[i].size();++j){
            bns[i].push_back(0);
            while(tp%ans[i][j]==0)
            {
                bns[i][j]++;
                tp/=ans[i][j];
            }
        }
    }
}


int main()
{
    ios::sync_with_stdio(false);
    int n;
    cin>>n;

//    clock_t start,finish;
//    double totaltime;
//    start=clock();
    init1(n);
    init2(n);
//    finish=clock();
//    totaltime=(double)(finish-start)/CLOCKS_PER_SEC;
//    cout<<"\n处理出所有"<<n<<"个数质因数和对应指数的运行时间"<<totaltime<<"秒！"<<endl;

    //输出
    for(int i=1;i<=n;++i){
        cout<<i<<": ";
        for(int j=0;j<ans[i].size();++j)
            if(j==ans[i].size()-1) cout<<ans[i][j]<<'^'<<bns[i][j];
            else cout<<ans[i][j]<<'^'<<bns[i][j]<<" * ";
        cout<<endl;
    }
    return 0;
}

```





## 区间质因数分解(基于线性筛)

先$O(n)$欧拉筛求出每个数的**最小质因子** 

再$O(nlogn)$利用**区间信息**求出对应的指数

```c++
//注意多个vector push速度很慢
//若无需记录 尽量不用vector
#include<bits/stdc++.h>
using namespace std;

const int maxn=1e6+10;

vector<int> ans[maxn];
vector<int> bns[maxn];
int min_prime[maxn];
int tot;
int prime[maxn];

void init1(int n)//预处理每个数最小的质因子
{
    tot=0;
    for(int i=2;i<=n;++i){
        if(min_prime[i]==0){
            prime[++tot]=i;
            min_prime[i]=i;
        }
        for(int j=1;j<=tot && prime[j]*i<=n;++j){
            min_prime[prime[j]*i]=prime[j];
            if(i%prime[j]==0) break;
        }
    }
}


void init2(int n)
{
    for(int i=2;i<=n;++i){
        int tp=i;
        while(tp!=1)
        {
            int num=0;
            int tem=min_prime[tp];
            ans[i].push_back(tem);
            while(tp%tem==0)
            {
                num++;
                tp/=tem;
            }
            bns[i].push_back(num);
        }
    }
}

int main()
{
    int n;
    cin>>n;

    clock_t start,finish;
    double totaltime;
    start=clock();

    init1(n);
    init2(n);

    finish=clock();
    totaltime=(double)(finish-start)/CLOCKS_PER_SEC;
    cout<<"\n处理出所有"<<n<<"个数质因数和对应指数的运行时间"<<totaltime<<"秒！"<<endl;

    //输出
//    for(int i=1;i<=n;++i){
//        cout<<i<<": ";
//        for(int j=0;j<ans[i].size();++j)
//            if(j==ans[i].size()-1) cout<<ans[i][j]<<'^'<<bns[i][j];
//            else cout<<ans[i][j]<<'^'<<bns[i][j]<<" * ";
//        cout<<endl;
//    }
    return 0;
}


```



## 大区间素数筛(32位数任意1e6长度区间)基于埃筛

32位预处理1~16位 的素数

40位 1e6 理论上也行  预处理1~20位 的素数

```c++
#include<iostream>
#include<vector>
using namespace std;
typedef long long ll;
const int maxn=(1<<16)+10;
bool valid[maxn];
ll ans[maxn];

int tot;

void get_prime(int n)
{
    tot=0;
    for(int i=2;i<=n;++i) valid[i]=true;

    for(int i=2;i<=n;++i){
        if(valid[i]){
        ans[++tot]=i;
        }
        for(int j=1;j<=tot &&  ans[j]*i<=n;++j){
            valid[ans[j]*i]=false;
            if(i%ans[j]==0) break;
        }
    }
}

//<<4是为了1e6区间而已  <<2即可?
bool vis[maxn<<4];//用于被筛

int main()
{
    //求区间素数 闭区间
    ios::sync_with_stdio(false);
    get_prime(1<<16);
    ll L,R;
    while(cin>>L>>R)
    {
        for(int i=1;i<=(R-L+1);++i){//-L+1编号
            vis[i]=true;
        }
        if(L==1) vis[1]=false;//1不是素数
        //下面用素数筛
        for(int i=1;i<=tot;i++)
            for(ll j=max(ans[i],(L-1)/ans[i]+1);j<=R/ans[i];j++)//当前素数的j倍
                vis[ans[i]*j-L+1]=false;//ans[i]*j是合数

//(L-1)/ans[i]+1)找的是从L开始第一个ans[i]的倍数是其多少倍

//也可用下面这种写法 但要unsigned int    慢多少？
//        for(int i=1;i<=tot;++i){
//            for(unsigned int j=(L%ans[i]==0?L:L+ans[i]-L%ans[i]);j<=R;j+=ans[i]){
//                if(j==ans[i]) continue;//自己是质数
//                vis[j-L+1]=false;//j是合数
//            }
//        }

//考虑这里为什么当L较小时 从ans[i]倍ans[i]开始筛 (当L较大时自然从(L-1)/ans[i]+1倍开始)
//能从ans[i]*ans[i]开始的条件是 ans[i]的ans[i-1]倍、ans[i-2]倍...已经筛过了(如果在L,R区间里)
//那当i=i-1、i-2...时不就是吗 证毕
//也许会问
//1.如果ans[k],k<i 小于 (L-1)/ans[k]+1呢? 辣就从  (L-1)/ans[k]+1倍开始 这样才在L,R区间内
//2.如果ans[k],k<i 大于 (L-1)/ans[k]+1呢? 辣就从  ans[k]开始，上面讨论的ans[i](i>k)的ans[k]倍就是在这筛去的，即ans[k]的ans[i]倍

        vector<ll> tep;//答案
        for(int i=1;i<=(R-L+1);++i){
            if(vis[i]) tep.push_back(L+i-1);
        }
        cout<<tep.size()<<endl;
//        for(int i=0;i<tep.size();++i){
//            cout<<tep[i]<<' ';
//        }
        cout<<endl;
    }
    return 0;
}
```





## 大区间质因数分解(32位数任意1e6长度区间)基于埃筛

32位预处理1~16位 的素数

40位 1e6 理论上也行  预处理1~20位 的素数

**先埃筛求出小于等于根号n的所有质因子，然后对于区间内的每个数直接除**

**因为一个合数n必定有小于等于$\sqrt{n}$ 的质因子   将其全部除尽后 若不为1 则为大于$\sqrt{n}$的质因子 且仅有一个**

处理质因子时间$O(1e6*log(1e6))$ 

除法时间为$O(l*log(n))$ 其中l为区间长度  n为32位数  

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn=(1<<16)+10;

bool valid[maxn];
int prime[maxn];
int tot;

void get_prime(int n)
{
    tot=0;
    for(int i=2;i<=n;++i) valid[i]=true;
    for(int i=2;i<=n;++i){
        if(valid[i]==true){
            prime[++tot]=i;
        }
        for(int j=1;j<=tot && prime[j]*i<=n;++j){
            valid[prime[j]*i]=false;
            if(i%prime[j]==0) break;
        }
    }
}

//<<2是为了1e6区间而已
vector<int> ans[maxn<<2];//区间每个数的质因子
vector<int> bns[maxn<<2];//质因子对应的指数

int main()
{
    //freopen("out.txt","w",stdout);
    ios::sync_with_stdio(false);
    get_prime(1<<16);
    int L,R;
    cin>>L>>R;
    for(int i=1;i<=tot;++i){
        for(int j=(L-1)/prime[i]+1;j<=R/prime[i];++j){
            ans[j*prime[i]-L].push_back(prime[i]);
        }
    }

    //L存在0这里
    for(int i=0;i<R-L+1;++i){
        if(ans[i].size()==0){
            ans[i].push_back(i),bns[i].push_back(1);
            continue;
        }
        int x=i+L;
        for(int j=0;j<ans[i].size();++j){
            int tp=ans[i][j];
            int num=0;
            while(x%tp==0){
                x/=tp;
                num++;
            }
            bns[i].push_back(num);
        }
        if(x!=1) ans[i].push_back(x),bns[i].push_back(1);
    }
    //输出
    for(int i=0;i<R-L+1;++i){
        cout<<i+L<<": ";
        for(int j=0;j<ans[i].size();++j)
            if(j==ans[i].size()-1) cout<<ans[i][j]<<'^'<<bns[i][j];
            else cout<<ans[i][j]<<'^'<<bns[i][j]<<" * ";
        cout<<endl;
    }
    return 0;
}

```


## 完全数

一个数所有的真因子之和等于这个数。

![img](https://s1.ax2x.com/2018/09/05/5BnZ3Y.png)

正整数$n$是一个偶完全数，当且仅当$n=2^{m-1}(2^m-1)$，其中$m>=2$是使得$2^m-1$是一个素数的素数。

几个结论：

* 目前还没找到奇完全数
* 每个完全数的全部因数倒数之和都是2
* 除了6以外的完全数，每个都可以表示成连续奇数的立方和
* 每个完全数都可以表示成2的一些连续正整数次幂之和
* 完全是都是以6、8结尾



## 将数分解为平方之和

$$
(u^2+v^2)(A^2+B^2)=(uA+vB)^2+(vA-uB)^2
$$

使用上述公式，可以利用“乘性”

**定理  两平方数之和定理**  设$m$是正整数

- 将$m$质因子这样分解后

$$
m=p_1p_2...p_rM^2
$$

**其中$p_1,p_2,...,p_r$是互不相同的素因子，则$m$可以表示成两个平方数之和的充要条件是每个$p_i$或为2或为模4余1**

> 或者说一个数 n 是两个平方之和，当且仅当在 n 的质因子分解中，它的所有形如 4m + 3 的素因子都有偶次幂。
>
> 写程序时，可以对每个4m+3的素因子判断（2和4m+1的不用管），其指数应为偶数，若为奇数则return false



- $m$能表示成$m=a^2+b^2$，且$gcd(a,b)=1$，当且仅当以下两个条件之一成立：

1. $m$是奇数，且$m$的每个素因子都模4余1
2. $m$是偶数，$m/2$是奇数且$m/2$的每个素因子都模4余1





**回顾一下，本原勾股数组**

**定理2.1 （勾股数组定理）.**  每个本原勾股数组（a,b,c)（a为奇数，b为偶数)都可从如下公式得出：
$$
a=st ,\quad  b=\frac{s^2-t^2}{2},\quad  c=\frac{s^2+t^2}{2}
$$
其中s>t>=1是任意没有公因数的奇数，即互质的奇数



**有以上两条定理可知，$c$是一个本原勾股数组的斜边当且仅当方程**
$$
2c=s^2+t^2
$$
**有互素的奇整数解$s,t$**  

且有如下命题

**毕达哥拉斯斜边命题**  $c$是一个本原勾股数组斜边的充要条件是$c$ 是模4余1的素数的乘积。





**可能出的题目？**

* **对于给定长度的区间（1e6）数值在32位以内，求其中能分解为平方之和的数。**解法：大区间质因子分解$O(1e6*log1e6)$，对于区间每个数的每个质因子遍历$O(1e6*log1e9)$，看是否满足条件，若满足则要再花费log时间合并平方和，求出这两个平方数。总时间复杂度$O(1e6*log^21e9)$ 。
* **求解本原勾股数组**。即求解斜边$c$，满足$2c=s^2+t^2$，则对奇数$c$进行质因子分解，看是否每个质因子满足模4余1，若满足，则可分解$2c$，合并平方和法求解出$s,t$，而$a=st ,\quad  b=\frac{s^2-t^2}{2},\quad$ 解毕。



---



**例题1**

编写求解一个数是否可以表示成平方和，若可以则**输出两个平方数（答案不唯一）**，否则输出-1

如果该数本身就是平方数，则不予处理（实际上就是求本原勾股数组）

**时间复杂度**  $O(\sqrt{n}+log^3n)$   $n$大约$1e16$可解 

若使用$Pollard\_Rho$质因子分解，则时间复杂度可以降到$O(n^\frac{1}{4}+log^3n)$ 

```c++
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
typedef long long ll;
typedef pair<ll,ll> pll;

const int maxn=100;

ll a[maxn];//质因子
int b[maxn];//质因子的指数
int tot;//1~tot

void factor(ll n)
{
    ll temp,now;
    temp=(int)((double)sqrt(n)+1);
    now=n;
    tot=0;
    //不用等于？
    for(int i=2;i<temp;++i) if(now%i==0){
        a[++tot]=i;
        b[tot]=0;
        while(now%i==0){
            ++b[tot];
            now/=i;
        }
    }
    if(now!=1){//一个合数n必定有小于等于sqrt{n} 的质因子   将其全部除尽后 若不为1 则为大于sqrt{n}的质因子 且仅有一个
        a[++tot]=now;
        b[tot]=1;
    }
}

ll mod_mul(ll a,ll b,ll c){//a*b %c 乘法改加法 防止超long long
    ll res=0;
    a=a%c;
    assert(b>=0);
    while(b)
    {
        if(b&1) res=(res+a)%c;
        b>>=1;
        a=(a+a)%c;
    }
    return res;
}

ll fast_exp(ll a,ll b,ll c){
    ll res=1;
    a=a%c;
    assert(b>=0);
    while(b>0)
    {
        if(b&1) res=mod_mul(a,res,c);
        b=b>>1;
        a=mod_mul(a,a,c);
    }
    return res;
}

//求解x^2 \equiv -1 (mod p)
ll ran(ll n){
    //要保证n%4=1
    assert(n%4==1);
    srand(time(0));
    for(;;){
        ll a=rand()%(n-1)+1;//1~ n-1
        ll b=fast_exp(a,(n-1)/4,n);
        if(mod_mul(b,b,n)==n-1) return b<=(n-1)/2 ? b:n-b;
    }
}

pll solve1(ll p)
{
    //算法保证M<p
    if(p==2) return mp(1,1);
    if(p%4!=1) return mp(-1,-1);
    ll A,B,u,v,M;
    A=ran(p); B=1;
    //__int128 tmp=1;
    ll tmp=1;
    M=ll((tmp*A*A+tmp*B*B)/p);
    while(M>1)
    {
        u=(A%M+M)%M;v=(B%M+M)%M;//注意可能是负数
        if(2*u>M) u-=M;
        if(2*v>M) v-=M;
        assert(u<=M/2 && u>=-M/2);
        assert(v<=M/2 && v>=-M/2);
        ll ta=A;
        A=ll((tmp*u*A+tmp*v*B)/M);
        B=ll((tmp*v*ta-tmp*u*B)/M);
        M=ll((tmp*u*u+tmp*v*v)/M);
    }
    return make_pair(min(abs(A),abs(B)),max(abs(A),abs(B)));
}

bool check_2(ll n){
    factor(n);
    for(int i=1;i<=tot;++i){
        if(a[i]%4==3 && b[i]%2==1) return false;
    }
    return true;
}

pll solve2(ll n){
    ll M=1;//n=p1p2..pr M^2
    pll ans,tmp;ll tx,ty;
    vector<int> odd;
    for(int i=1;i<=tot;++i){
        for(int j=1;j<=b[i]/2;++j) M*=a[i];//还剩奇数的
        if(b[i]%2==1) odd.push_back(i);
    }
    assert(odd.size());
    ans=solve1(a[odd[0]]);
    //cout<<ans.first<<" "<<ans.second<<endl;
    for(int i=1;i<odd.size();++i){//由于n不是完全平方数 则odd中至少有一个数
        tmp=solve1(a[odd[i]]);
        tx=ans.first;ty=ans.second;
        ans.first=abs(tx*tmp.first+ty*tmp.second);
        ans.second=abs(ty*tmp.first-tx*tmp.second);
    }
    ans.first*=M;
    ans.second*=M;
    return ans;
}

bool check_1(ll n){
    ll tmp=ll(sqrt(n)+0.5);
    if(tmp*tmp==n) return true;
    return false;
}

int main()
{
    ios::sync_with_stdio(false);
    ll n;
    cin>>n;
    if(check_1(n)) cout<<"本身是完全平方数"<<endl;//检验是平方数
    else if(!check_2(n)) cout<<-1<<endl;
    else{
        pll ans=solve2(n);
        ll x=ans.first;ll y=ans.second;
        cout<<n<<"="<<x<<"^2 +"<<y<<"^2"<<endl;//答案不唯一
    }
    return 0;
}
```





**例题2**

[Timus Online Judge](http://acm.timus.ru/)1593

给一个数$N$，判断这个数最少能够使用多少个正整数的平方和来表示。

$N ≤ 10^{15}$

有以下几个结论：

* $n ≠ 4^a(8m + 7) $ 是 $n$ 可以用三个平方数表示的一个**充分必要条件**
* 每个正整数都是四个平方数之和

**时间复杂度**  $O(n^\frac{1}{2}+logn)$  （判断是否是两个数平方和的时间） 在TimusOj上跑了0.3s

```c++
//[Timus Online Judge](http://acm.timus.ru/)1593
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
typedef long long ll;
typedef pair<ll,ll> pll;

const int maxn=100;

ll a[maxn];//质因子
int b[maxn];//质因子的指数
int tot;//1~tot

void factor(ll n)
{
    ll temp,now;
    temp=(int)((double)sqrt(n)+1);
    now=n;
    tot=0;
    //不用等于？
    for(int i=2;i<temp;++i) if(now%i==0){
        a[++tot]=i;
        b[tot]=0;
        while(now%i==0){
            ++b[tot];
            now/=i;
        }
    }
    if(now!=1){//一个合数n必定有小于等于sqrt{n} 的质因子   将其全部除尽后 若不为1 则为大于sqrt{n}的质因子 且仅有一个
        a[++tot]=now;
        b[tot]=1;
    }
}

bool check_1(ll n){
    ll tmp=ll(sqrt(n)+0.5);
    if(tmp*tmp==n) return true;
    return false;
}

bool check_2(ll n){
    factor(n);
    for(int i=1;i<=tot;++i){
        if(a[i]%4==3 && b[i]%2==1) return false;
    }
    return true;
}

//n ≠ 4^a(8m + 7) 是 n 可以用三个平方数表示的一个充分必要条件
bool check_3(ll n){
    //枚举4^a
    ll tp=1;
    while(tp<n){
        if(n%tp==0 && (n/tp)%8==7) return false;
        tp*=4;
    }
    return true;
}

int solve(ll n){
    if(check_1(n)) return 1;
    if(check_2(n)) return 2;
    if(check_3(n)) return 3;
    return 4;
}

//每个整数一定可以表示成四个数的平方和
int main()
{
    ios::sync_with_stdio(false);
    ll n;
    cin>>n;
    cout<<solve(n)<<endl;
    return 0;
}
```


## 将素数分解为平方之和

**定理**  设$p$是素数，则$p$是两平方数之和的充要条件是$p\equiv 1 \ (mod \ 4)   $ 或$p=2$



**费马降阶法**

![img](https://s1.ax2x.com/2018/08/20/59rBWe.png)



**时间复杂度**  $O(log^2n)$    

注意  $\_\_int128$ 的使用

```c++
//HDU 3542 （费马降阶法）
//将素数表示成平方之和
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> pll;
#define mp make_pair

ll mod_mul(ll a,ll b,ll c){//a*b %c 乘法改加法 防止超long long
    ll res=0;
    a=a%c;
    assert(b>=0);
    while(b)
    {
        if(b&1) res=(res+a)%c;
        b>>=1;
        a=(a+a)%c;
    }
    return res;
}

ll fast_exp(ll a,ll b,ll c){
    ll res=1;
    a=a%c;
    assert(b>=0);
    while(b>0)
    {
        if(b&1) res=mod_mul(a,res,c);
        b=b>>1;
        a=mod_mul(a,a,c);
    }
    return res;
}

//求解x^2 \equiv -1 (mod p)
ll ran(ll n){
    //要保证n%4=1
    assert(n%4==1);
    srand(time(0));
    for(;;){
        ll a=rand()%(n-1)+1;//1~ n-1
        ll b=fast_exp(a,(n-1)/4,n);
        if(mod_mul(b,b,n)==n-1) return b<=(n-1)/2 ? b:n-b;
    }
}

pll solve(ll p)
{
    //算法保证M<p
    if(p==2) return mp(1,1);
    if(p%4!=1) return mp(-1,-1);
    ll A,B,u,v,M;
    A=ran(p); B=1;
    __int128 tmp=1;
    //ll tmp=1;
    M=ll((tmp*A*A+tmp*B*B)/p);
    while(M>1)
    {
        u=(A%M+M)%M;v=(B%M+M)%M;//注意可能是负数
        if(2*u>M) u-=M;
        if(2*v>M) v-=M;
        assert(u<=M/2 && u>=-M/2);
        assert(v<=M/2 && v>=-M/2);
        ll ta=A;
        A=ll((tmp*u*A+tmp*v*B)/M);
        B=ll((tmp*v*ta-tmp*u*B)/M);
        M=ll((tmp*u*u+tmp*v*v)/M);
    }
    return make_pair(min(abs(A),abs(B)),max(abs(A),abs(B)));
}

int main()
{
//    freopen("1.in","r",stdin);
//    freopen("1.out","w",stdout);
    int t;
    cin>>t;
    while(t--){
        ll p;
        cin>>p;
        pll ans=solve(p);
        if(ans.first==-1) cout<<-1<<endl;
        else{
            ll x=ans.first;ll y=ans.second;
            cout<<x*x<<endl;
            assert(x<y);
            assert((x*x+y*y)==p);
        }
    }
    return 0;
}
```

## N次剩余

给定$N,a,p$，求出$x^N\equiv a\ (mod \ p)$在模$p$意义下的所有解（其中$p$是素数） 



如果能找到原根$g$，则$\{1,2,..,.p-1\}$与$\{g^1,g^2,...,g^{p-1}\}$之间就建立了双射关系。

令$g^y=x,g^t=a$，$x^N\equiv a\ (mod \ p)$ ，则有
$$
g^{y*N}\equiv g^t  \quad (mod \ p)
$$
因为$p$是素数，所以方程左右都不会为0。原问题转化为：
$$
N*y\equiv t\ (mod \ (p-1))
$$
由于$N,p$已知，则上式为**解模线性方程**。

而$t$的值，由$g^t\equiv a \ (mod\ p)$，用解**离散对数**的方法求出。



**时间复杂度**  $O(\sqrt{p}log(\sqrt{p}))$  



```c++
//51Nod - 1038
//N次剩余 O(\sqrt{p}*大常数)
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

struct pli{
    ll first;
    int second;
    pli(){}
    pli (ll x_,int y_){
        first=x_;
        second=y_;
    }
    bool operator < (const pli &b) const {
        if(first==b.first) return second>b.second;//因为second更大的解更小，所以重载>
        return first<b.first;
    }
};

//ll mod_mul(ll a,ll b,ll c){//a*b %c 乘法改加法 防止超long long
//    ll res=0;
//    a=a%c;
//    assert(b>=0);
//    while(b)
//    {
//        if(b&1) res=(res+a)%c;
//        b>>=1;
//        a=(a+a)%c;
//    }
//    return res;
//}

ll fast_exp(ll a,ll b,ll c){
    ll res=1;
    a=a%c;
    assert(b>=0);
    while(b>0)
    {
        if(b&1) res=(a*res)%c;
        b=b>>1;
        a=(a*a)%c;
    }
    return res;
}

vector<ll> a;//p-1的所有质因子
bool g_test(ll g,ll p){
    for(ll i=0;i<a.size();++i)
        if(fast_exp(g,(p-1)/a[i],p)==1)//非素数时，要将p-1换为\varphi(p)
            return 0;
    return 1;
}

ll primitive_root(ll p)
{
    a.clear();
    ll tmp=p-1;//非素数时，要将p-1换为\varphi(p)
    for(ll i=2;i<=tmp/i;++i)
        if(tmp%i==0){
            a.push_back(i);
            while(tmp%i==0) tmp/=i;
        }
    if(tmp!=1) a.push_back(tmp);
    long long g=1;
    while(1)
    {
        if(g_test(g,p)) return g;
        ++g;
    }
}

ll gcd(ll a,ll b){
    if(b==0) return a;
    return gcd(b,a%b);
}

//a^x\equiv b (mod m)
ll bsgs(ll a,ll b,ll m)
{
    a%=m,b%=m;
    if(b==1) return 0;
    int cnt=0;
    ll t=1;
    for(ll g=gcd(a,m);g!=1;g=gcd(a,m)){
        if(b % g) return -1;
        m/=g , b/=g , t = t * a / g % m;//记录下要算逆元的值
        ++cnt;
        if(b==t) return cnt;
    }
    //cout<<a<<" "<<b<<" "<<m<<endl;
    //bsgs
    int M=int(sqrt(m)+1);//这里的m不等于参数中的值了
    ll base=b;
//    std::unordered_map<ll,int> hash;
//    for(int i=0;i!=M;++i){
//        hash[base]=i;//存的是大的编号
//        base=base*a%m;
//    }
//    base=fast_exp(a,M,m);//必要时要用快速乘
//    ll now=t;
//    for(int i=1;i<=M+1;++i){
//        now=now*base%m;//这里乘在左边了 相当于右边乘逆元
//        if(hash.count(now)) return i*M-hash[now]+cnt;
//    }
    pli hash[int(1e5)];
    for(int i=0;i!=M;++i){
        hash[i]=pli(base,i);
        base=base*a%m;
    }
    sort(hash,hash+M);//默认以first
    base=fast_exp(a,M,m);
    ll now=t;
    for(int i=1;i<=M+1;++i){
        now=now*base%m;
        //找大于等于now的值
        //注意下面M+10  这样可以保证解最小，若设为-1,则找不到解了
        int id=lower_bound(hash,hash+M,pli(now,M+10))-hash;//默认是first
        assert(id>=0 &&id<=M);
        if(id!=M && hash[id].first==now) return i*M-hash[id].second+cnt;//减去的编号second越大越好
    }
    return -1;
}

ll e_gcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0){
        x=1;
        y=0;
        return a;
    }
    ll ans=e_gcd(b,a%b,x,y);
    ll temp=x;
    x=y;
    y=temp-a/b*y;
    return ans;
}

vector<int> residue(int p,int N,int a){
    int g=primitive_root(p);
    ll t=bsgs(g,a,p);
    vector<int> ans;
    if(a==0){
        ans.push_back(0);
        return ans;
    }
    if(t==-1) return ans;
    //解不定方程
    ll A=N,B=p-1,C=t,x,y;
    ll d=e_gcd(A,B,x,y);
    if(C % d !=0) return ans;
    x=x*(C/d)%B;
    ll delta=B/d;
    for(int i=0;i<d;++i){//一共d组解
        x=((x+delta)%B+B)%B;
        ans.push_back((int)fast_exp(g,x,p));
    }
    sort(ans.begin(),ans.end());
//unique的作用是“去掉”容器中相邻元素的重复元素（不一定要求数组有序），
//它会把重复的元素添加到容器末尾（所以数组大小并没有改变），而返回值是去重之后的尾地址
    ans.erase(unique(ans.begin(),ans.end()),ans.end());
    return ans;
}

int main()
{
    ios::sync_with_stdio(false);
    int t,p,N,A;
    //x^N=A (mod p)
    cin>>t;
    while(t--)
    {
        cin>>p>>N>>A;
        vector<int> ans=residue(p,N,A);
        if(ans.size()){
            for(int i=0;i<ans.size()-1;++i){
                cout<<ans[i]<<" ";
            }
            cout<<*ans.rbegin()<<endl;
        }
        else cout<<"No Solution"<<endl;
    }
    return 0;
}
```

## 二次互反律

**$a$模$p$的勒让德符号是**
$$
\left(\frac{a}{p}\right)=\left\{\begin{matrix}
1  \quad  若a是模p的二次剩余 \\  
-1 \quad 若a是模p的二次非剩余
\end{matrix}\right.
$$

**欧拉准则： ** 设$p$为素数，则（**直接用快速幂计算**）
$$
a^\frac{p-1}{2}\equiv  \left( \frac{a}{p} \right) \quad mod \ p
$$
**勒让德符号满足积性**
$$
\left(\frac{a}{p}\right)\left(\frac{b}{p}\right)=\left(\frac{ab}{p}\right)
$$



**定理  广义二次互反律**  设$a,b$为正奇数，则

![img](https://s1.ax2x.com/2018/08/16/59VdpO.png) 

![img](https://s1.ax2x.com/2018/08/16/59VjKq.png) 

---



使用二次互反律求解勒让德符号  （**当然也可以直接用欧拉准则，快速幂即可**）

**时间复杂度**  $O(logb)$



```c++
//poj 1808
#include<iostream>
#include<assert.h>
using namespace std;

typedef long long ll;

ll a,p;//求解勒让德符号(a/p)

ll Legendre(ll a,ll p)
{
    a=a%p;
    if(a<0) a+=p;
    int num=0;//将a的2次幂提出 保证是奇数
    while(a%2==0){
        a>>=1;
        num++;
    }
    ll ans1,ans2=1;//ans2是2的次幂的答案,默认为1
    if(a==1) ans1=1;
    else if(a==2){
        if(p%8==1||p%8==7) ans1=1;
        else ans1=-1;
    }
//    else if(a==p-1){
//        if(p%4==1) ans1=1;
//        else ans1=-1;
//    }
    else{
        if(p%4==3 && a%4==3) ans1=-Legendre(p,a);
        else ans1=Legendre(p,a);
    }
    if(num%2 &&(p%8==3||p%8==5)) ans2=-1;
    return ans1*ans2;
}

int main()
{
    int t;
    cin>>t;
    int T=0;
    while(t--)
    {
        T++;
        cin>>a>>p;
        cout<<"Scenario #"<<T<<":"<<endl<<Legendre(a,p)<<endl<<endl;
    }
    return 0;
}

```



## 二次剩余

**定理**  设$p$为一个奇素数，则恰有$\frac{p-1}{2}$个模$p$的二次剩余（即原根的偶次幂模$p$），且恰有$\frac{p-1}{2}$个模$p$的二次非剩余。



**$a$模$p$的勒让德符号是**
$$
\left(\frac{a}{p}\right)=\left\{\begin{matrix}
1  \quad  若a是模p的二次剩余 \\  
-1 \quad 若a是模p的二次非剩余
\end{matrix}\right.
$$
使用**二次互反律**可以快速计算一个数$a$是不是模$p$的二次剩余。

当然直接用**欧拉准则**来判别更方便

---

$ACM$中更常见的问题是，不仅判断是不是二次剩余，还要求解对应的底数。

给定$a,n$，其中$n$是素数，求$x^2\equiv a\ (mod \ n)$的最小整数解$x$。



**思路**  先判断是否有解，再根据剩余类特殊判断

输出满足同余式的较小解$x$  ，$-1$表示无解

取较小的辣个解  可以保证有两个解，且是对称的

即$x=[1,p-1],[2,p-2],...,[(p-1)/2,(p+1)/2]$对应的剩余是一样的



**时间复杂度**  $O(log^2n)$

(相当于求解勒让德符号的基础上，又给出了解，这里勒让德符号的判断直接使用欧拉准则)



```c++
#include<iostream>
using namespace std;

typedef long long ll;

ll fast_exp(ll a,ll b,ll c){
    ll res=1;
    a=a%c;
    while(b)
    {
        if(b&1) res=(res*a)%c;
        b>>=1;
        a=(a*a)%c;
    }
    return res;
}

//x^2 \equiv a (mod n)
ll modsqr(ll a,ll n){
    a=(a%n+n)%n;
    if(a==0) return 0;//这里考虑了解x=0的情况 一般只考虑[1,p-1]
    ll b,k,i,x;
    if(n==2) return a%n;
    if(fast_exp(a,(n-1)/2,n)!=1) return -1;
    //-----------------------------------------
    if(n%4==3) x=fast_exp(a,(n+1)/4,n);
    else{//求解n%4==1
        for(b=1;fast_exp(b,(n-1)/2,n)==1;b++);
        i=(n-1)/2;
        k=0;
        do{
            i/=2;
            k/=2;
            if((fast_exp(a,i,n)*(ll)fast_exp(b,k,n)+1)%n==0)  k+=(n-1)/2;
        }while(i%2==0);
        x=(fast_exp(a,(i+1)/2,n)*(ll)fast_exp(b,k/2,n))%n;
    }
    if(x * 2 >n) x=n-x;//取较小的辣个解  可以保证有两个解，且是对称的
    //即x=[1,p-1],[2,p-2],...,[(p-1)/2,(p+1)/2]对应的剩余是一样的
    return x;
}

int main()
{
    cout<<modsqr(0,48611)<<endl;
    return 0;
}
```





**特殊二次剩余**（比上面板子快常数倍）

当$p$模4余1时，求解$x^2\equiv -1 \ (mod \ p)$，可以直接使用二次剩余的板子，也可以使用随机算法。

即随机一个$a∈[1,p-1]$ ，求解$b\equiv a^{(p-1)/4}\ (mod\ p)$，可知$b^2\equiv (\frac{a}{p}) \ (mod\ p)$，即若选取的$a$不是$p$的二次剩余（有一半的概率），则求得的$b$即为解$x$。

由定理知有两个解$x_1,x_2$，且$x_1+x_2=p$。

```c++
//求解x^2 \equiv -1 (mod p)
ll ran(ll n){
    //要保证n%4=1
    assert(n%4==1);
    srand(time(0));
    for(;;){
        ll a=rand()*rand()%(n-1)+1;
        ll b=fast_exp(a,(n-1)/4,n);
        if(b*b%n==n-1) return b<=(n-1)/2 ? b:n-b;//若爆long long 则用快速乘
    }
}
```

## 单变元模线性方程（同余方程）

求解不定方程



```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

//拓展欧几里得模板
ll e_gcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0){
        x=1;
        y=0;
        return a;
    }
    ll ans=e_gcd(b,a%b,x,y);
    ll temp=x;
    x=y;
    y=temp-a/b*y;
    return ans;
}

//ax同余b(mod n) 输出[0,n) 中的解
vector<long long> line_mod_equation(long long a,long long b,long long n){
    long long x,y;
    long long d=e_gcd(a,n,x,y);
    vector<long long>ans;
    ans.clear();
    if(b%d==0){
        x=(x%n+n)%n;
        ans.push_back(x*(b/d)%(n/d));//最小正整数解
        for(long long i=1;i<d;++i)//mod n意义下有d(gcd?)个解
            ans.push_back((ans[0]+i*n/d)%n);
    }
    return ans;
}

vector<long long>ans;

int main()
{
    ios::sync_with_stdio(false);
    ll a,b,mod;
    cin>>a>>b>>mod;
    ans=line_mod_equation(a,b,mod);
    if(!ans.size()) cout<<"无解"<<endl;
    else{
        for(int i=0;i<ans.size();++i){
            cout<<ans[i]<<' ';
        }
    }
    return 0;
}

```







## 中国剩余定理（CRT） 同余方程组

求出方程组$x\equiv a_i(mod \ m_i) (0 \leqslant i <n) $ 的解x

其中$m_0,m_1,m_2,m_3...m_{n-1}$ 两两互质



**解：**

令$M_i=\prod_{j\neq i}m_j$     则有$(M_i,m_i)=1$   

故存在$p_i,q_i$ ，使得$M_i*p_i+m_i*q_i=1$ 

令  $e_i=M_ip_i$   ,    $p_i$即为$M_i$ 模$m_i$下的逆元          $(M_i,m_i)=1$   

则有
$$
e_i\equiv

\left\{\begin{matrix}
 0(mod\ m_j),j\neq i \\ 
 1(mod\ m_j),j=i
\end{matrix}\right.
$$
故$e_0a_0+e_1a_1+e_2a_2+...+e_{n-1}a_{n-1}$是方程的一个解

由**中国剩余定理**知，$[0\sim\prod_{i=0}^{n-1}m_i\}$ 中必有一解  

将上式模$\prod_{i=0}^{n-1}m_i$即可 



**时间复杂度**  $O(nlogm)$    $n$个方程

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int maxn=101;//方程个数

//拓展欧几里得模板
ll e_gcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0){
        x=1;
        y=0;
        return a;
    }
    ll ans=e_gcd(b,a%b,x,y);
    ll temp=x;
    x=y;
    y=temp-a/b*y;
    return ans;
}

//x同余a  mod m
//a为方程右值 m为方程的模 n为方程数
//下标从0开始
ll CRT(ll a[],ll m[],int n){
    ll M=1;
    for(int i=0;i<n;++i) M*=m[i];
    ll ret=0;
    for(int i=0;i<n;++i){
        ll x,y;
        ll tm=M/m[i];
        ll tmp=e_gcd(tm,m[i],x,y);//tm 和 m[i]互质  只有一个解
        //cout<<x<<endl;
        ret=(ret+tm*x*a[i])%M;//这里x可能为负值  但不影响结果
    }
    return (ret+M)%M;
}

ll a[maxn];
ll m[maxn];
int n;

int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=0;i<n;++i)
        cin>>a[i]>>m[i];
    cout<<"一个解为:"<<CRT(a,m,n)<<endl;
    return 0;
}

```




## 广义欧拉降幂

如何计算$5^{100000000000000}mod\ 12830603$?

如果12830603是素数，则直接使用费马小定理，可以将指数除以p-1，将余数作为幂计算即可。

但12830603=3571*3593，不是素数。

但但，$gcd(5,12830603)=1$，因此$5^{\varphi(12830603)}\equiv 1 (mod \ 12830603)$

计算得到$\varphi(12830603)=12823440$，因此只要把100..000除以12823440的余数作为指数。

注意这里要求5和12830603互质。

如果底数和模数不互质呢？有广义欧拉降幂公式，总结如下：
$$
\begin{align}
a^b\equiv _{mod \ p} \left\{\begin{matrix}
 a^{b\% \phi(p)}&  \quad gcd(a,p)=1 \\
a^b   \quad  & gcd(a,p)\neq 1,b<\phi(p) \\
a^{b\% \phi(p)+\phi(p)} &\quad   gcd(a,p)\neq 1,b\ge \phi(p)
\end{matrix}\right.
\end{align}
$$



**例题1**    求2的2的2的2的....次方模p ,p<1e7

我们对指数进行降幂，递归即可，可以保证在$log$步内会停止 

时间复杂度  $O(log_2p*\sqrt{p})$ 

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

//O sqrt(p) 求解欧拉函数
int phi(int x)
{
    int res=x;
    for(int i=2;i*i<=x;++i){
        if(x%i==0){
            res-=res/i;
            do{
                x/=i;
            }while(x%i==0);
        }
    }
    if(x>1) res-=res/x;
    return res;
}


ll fast_exp(ll a,ll b,ll c)
{
    ll res=1;
    a=a%c;
    assert(b>=0);
    while(b)
    {
        if(b&1){
            res=res*a%c;
        }
        a=a*a%c;
        b>>=1;
    }
    return res;
}


ll solve(ll p)//模p
{
    if(p==1) return 0;
    int ph=phi(p);
    return fast_exp(2,solve(ph)+ph,p);//广义欧拉公式 由于是无穷次幂 一定大于phi(p)
}

int main()
{
    ios::sync_with_stdio(false);
    int t;
    cin>>t;
    while(t--)
    {
        ll p;
        cin>>p;
        cout<<solve(p)<<endl;
    }
    return 0;
}
```





**例题2**   

计算$A^B mod C$ 

$(1<=A,C<=1000000000,1<=B<=10^{1000000}).$

``` c++
#include<iostream>
using namespace std;

typedef long long ll;

ll gcd(ll a,ll b)
{
    if(b==0) return a;
    return gcd(b,a%b);
}

//O sqrt(p) 求解欧拉函数
ll phi(ll x)
{
    ll res=x;
    for(int i=2;i*i<=x;++i){
        if(x%i==0){
            res-=res/i;
            do{
                x/=i;
            }while(x%i==0);
        }
    }
    if(x>1) res-=res/x;
    return res;
}

ll fast_exp(ll a,ll b,ll c)
{
    ll res=1;
    a=a%c;
    //assert(b>=0);
    while(b)
    {
        if(b&1){
            res=res*a%c;
        }
        a=a*a%c;
        b>>=1;
    }
    return res;
}

ll fun(string b,ll mod)
{
    ll res=0;
    for(int i=0;i<b.size();++i){
        res=res*10+b[i]-'0';
        res%=mod;
    }
    return res;
}

int main()
{
    ios::sync_with_stdio(false);
    ll a,c;
    string b;
    while(cin>>a>>b>>c)
    {
        if(b.size()<11) cout<<fast_exp(a,fun(b,1e12),c)<<endl;//fun(b,1e12) 相当于将b转为数字
        else if(gcd(a,c)==1) cout<<fast_exp(a,fun(b,phi(c)),c)<<endl;
        else cout<<fast_exp(a,fun(b,phi(c))+phi(c),c)<<endl;
    }
    return 0;
}

```



## 二分快速乘

```c++
ll mod_mul(ll a,ll b,ll c){//a*b %c 乘法改加法 防止超long long
    ll res=0;
    a=a%c;
    assert(b>=0);
    while(b)
    {
        if(b&1) res=(res+a)%c;
        b>>=1;
        a=(a+a)%c;
    }
    return res;
}
```





## 二分快速幂

```c++
typedef long long ll;

ll fast_exp(ll a,ll b,ll c){
    ll res=1;
    a=a%c;
    assert(b>=0);
    while(b>0)
    {
        if(b&1) res=(a*res)%c;
        b=b>>1;
        a=(a*a)%c;
    }
    return res;
}
```





## 矩阵快速幂求递推式(以fib为例)

已知$f_x=a_0f_{x-1}+a_1f_{x-2}+...+a_{n-1}f_{x-n}$和$f_0,f_1,...,f_{n-1}$，给定t，求$f_t$ 


$$
A=\begin{bmatrix}

0& 1 & 0&...&0\\
0& 0 &1 &...&0\\ 
..  & ..  &..&...&..\\
0& 0&0 &... &1\\
a_{n-1} & a_{n-2} &a_{n-3}&...&a_{0} 

\end{bmatrix},B=\begin{bmatrix}
f_{x-n}\\
f_{x-n+1}\\
..\\
..\\
f_{x-2}\\
f_{x-1}
\end{bmatrix}
$$

**时间复杂度    $O(n^3logt)$**



```c++
#include<iostream>
#include<string.h>
using namespace std;

const int maxn=101;
const int maxm=101;
int mod;//需要时使用

struct Matrix{
    int n,m;//行 列
    int a[maxn][maxm];//注意函数内数组大小不能超过500000int
    void Clear(){
        n=m=0;
        memset(a,0,sizeof(a));
    }

    Matrix operator +(const Matrix &b) const{
        Matrix tmp;
        tmp.n=n; tmp.m=m;
        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j)
                tmp.a[i][j]=a[i][j]+b.a[i][j];
        return tmp;
    }

    Matrix operator -(const Matrix &b) const{
        Matrix tmp;
        tmp.n=n; tmp.m=m;
        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j)
                tmp.a[i][j]=a[i][j]-b.a[i][j];
        return tmp;
    }

    Matrix operator *(const Matrix &b) const{
        Matrix tmp;
        tmp.Clear();
        tmp.n=n; tmp.m=b.m;
        for(int i=0;i<n;++i)
            for(int j=0;j<b.m;++j)
                for(int k=0;k<m;++k){
                    tmp.a[i][j]+=a[i][k]*b.a[k][j]%mod;
                    tmp.a[i][j]%=mod;
                }
        return tmp;
    }
};

int solve(int a[],int b[],int m,int t){
    //a是常系数数组 b是初值数组 m是数组大小 t是要求解的项数 从第0项开始 所以共有t+1项
    //m为已知递推式的阶数
    //输出函数在第t项的值f(t)
    //调用矩阵类
    Matrix M,F,res;//M是辅助常数矩阵 F是转移矩阵
    M.Clear(),F.Clear(),res.Clear();
    M.n=M.m=m;
    res.n=res.m=m;
    F.n=m,F.m=1;
    for(int i=0;i<m-1;++i)
        M.a[i][i+1]=1;
    for(int i=0;i<m;++i){
        M.a[m-1][i]=a[i];//a[i]先存小项的系数 即递推式最靠末尾的系数
        F.a[i][0]=b[i];//b[i]先存小项的值 即f0(通常)
        res.a[i][i]=1;//初始化为单位矩阵
    }
    if(t<m) return F.a[t][0];
    for(t-=m-1;t;t/=2){//t-=m-1为还要转移的次数
        if(t&1) res=M*res;
        M=M*M;
    }
    F=res*F;//res为最后的常数矩阵
    return F.a[m-1][0];
}


int main()
{
    //f[0]=0 f[1]=1
    mod=1000000007;
    int t;
    int a[2],b[2];
    a[0]=a[1]=1;
    b[0]=0;
    b[1]=1;
    while(cin>>t&&t!=-1)
    {
        cout<<solve(a,b,2,t)<<endl;
    }
    return 0;
}
```



## 离散对数

给定$a,b,m$，求$a^x\equiv b \ (mod \ m)$的解。

**Baby Step Giant Step：**   

首先解决$m=p$是质数的情况，我们设$x=A\left \lceil \sqrt{p} \right \rceil -B$，其中$0\le B< \left \lceil \sqrt{p} \right \rceil$， $0< A\le \left \lceil \sqrt{p} \right \rceil+1$，这样化简后的方程是
$$
a^{A\left \lceil \sqrt{p} \right \rceil}\equiv b\cdot a^B \quad (mod \ p)
$$
由于$A$和$B$值域都是$O(\sqrt{p})$级别的，所以可以先计算右边部分的值，存入$Hash$表，然后从小到大枚举$A$计算左边的值，在$Hash$表中查找。（当然，可以这样做的原因是一定存在$a$的逆元）即只要$gcd(a,m)=1$，上面的方法就是有效的。

**当$m$不是质数时**，我们要求解的是$a^x+km=b$，设$g=gcd(a,m)$，如果$g$不整除$b$，则无解，否则方程两边同除以$g$，得到$\frac{a}{g}a^{x-1}+k\frac{m}{g}=\frac{b}{g}$

这样便消去了一个因子，得到方程
$$
\frac{a}{g}a^{x-1}\equiv \frac{b}{g}\quad (mod \   \frac{m}{g})
$$
令${m}'=\frac{m}{g} ,\ b'=\frac{b}{g}(\frac{a}{g})^{-1}$， 得到
$$
a^{x'}\equiv b' \quad (mod \ m')
$$
得到的解加1即$x=x'+1$为原方程的解。

**但是**，进行一次这样的操作，新的方程不一定可以用bsgs求解，所以会进行多次。

如果中途出现$b'=1$则$x'=0$ 



**时间复杂度**  $O(\sqrt{m}log\sqrt{m})$        如果hash不用map则可以降低常数

求最小的$x$：

```c++
//SPOJ - MOD
//sqrt(m)*10  用map所以*10
//用二分常数较小*7大概
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

struct pli{
    ll first;
    int second;
    pli(){}
    pli (ll x_,int y_){
        first=x_;
        second=y_;
    }
    bool operator < (const pli &b) const {
        if(first==b.first) return second>b.second;//因为second更大的解更小，所以重载>
        return first<b.first;
    }
};

ll fast_exp(ll a,ll b,ll c){
    ll res=1;
    a=a%c;
    assert(b>=0);
    while(b>0)
    {
        if(b&1) res=(a*res)%c;
        b=b>>1;
        a=(a*a)%c;
    }
    return res;
}

ll gcd(ll a,ll b){
    if(b==0) return a;
    return gcd(b,a%b);
}

//a^x\equiv b (mod m)
ll bsgs(ll a,ll b,ll m)
{
    a%=m,b%=m;
    if(b==1) return 0;
    int cnt=0;
    ll t=1;
    for(ll g=gcd(a,m);g!=1;g=gcd(a,m)){
        if(b % g) return -1;
        m/=g , b/=g , t = t * a / g % m;//记录下要算逆元的值
        ++cnt;
        if(b==t) return cnt;
    }
    //cout<<a<<" "<<b<<" "<<m<<endl;
    //bsgs
    int M=int(sqrt(m)+1);//这里的m不等于参数中的值了
    ll base=b;
//    std::unordered_map<ll,int> hash;
//    for(int i=0;i!=M;++i){
//        hash[base]=i;//存的是大的编号，所以可以保证最小解
//        base=base*a%m;
//    }
//    base=fast_exp(a,M,m);//必要时要用快速乘
//    ll now=t;
//    for(int i=1;i<=M+1;++i){
//        now=now*base%m;//这里乘在左边了 相当于右边乘逆元
//        if(hash.count(now)) return i*M-hash[now]+cnt;
//    }
    pli hash[int(1e5)];
    for(int i=0;i!=M;++i){
        hash[i]=pli(base,i);
        base=base*a%m;
    }
    sort(hash,hash+M);//默认以first
    base=fast_exp(a,M,m);
    ll now=t;
    for(int i=1;i<=M+1;++i){
        now=now*base%m;
        //找大于等于now的值
        //注意下面M+10  这样可以保证解最小，若设为-1,则找不到解了
        int id=lower_bound(hash,hash+M,pli(now,M+10))-hash;//默认是first
        assert(id>=0 &&id<=M);
        if(id!=M && hash[id].first==now) return i*M-hash[id].second+cnt;//减去的编号second越大越好
    }
    return -1;
}

//10 1 7  1
int main()
{
    ll a,b,m;
    while(cin>>a>>m>>b,m)
    {
        ll ans=bsgs(a,b,m);
        if(ans==-1) cout<<"No Solution"<<endl;
        else{
            cout<<ans<<endl;
            assert(fast_exp(a,ans,m)==b%m);
        }
    }
    return 0;
}
```

## 逆元

**模质数**	   费马小定理

**模非质数**    拓展欧几里得

```c++
//拓展欧几里得
ll e_gcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0){x=1;y=0;return a;}
    ll ans=e_gcd(b,a%b,x,y);
    ll temp=x; x=y; y=temp-a/b*y;
    return ans;
}

//%mod逆元
ll inv(ll a,ll mod)
{
    ll ans,tmp;
    e_gcd(a,mod,ans,tmp);
    return (ans+mod)%mod;
}

```





## 线性求逆元

以求阶乘为例 

**线性逆元原理：**

设$p=ki+b$ ，那么$ki+b\equiv 0  (mod p)$ 

两边同乘以$i^{-1}，b^{-1}$ 得到$kb^{-1}+i^{-1}\equiv 0 \  (mod p)$  

$i^{-1}\equiv -kb^{-1}$ 

$i^{-1}\equiv -\lfloor\frac{p}{i}\rfloor * (p\%i)^{-1}$

通常在前面加上p(即mod) 

` inv[i]=((mod-mod/i)*(inv[mod%i]))%mod;`

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=10007;

ll inv[mod+10];
ll Fac[mod+10];
ll Fac_inv[mod+10];

void init()
{
    inv[1]=1;
    Fac[0]=1;
    Fac_inv[0]=1;
    for(int i=1;i<mod;++i){
        if(i!=1) inv[i]=((mod-mod/i)*(inv[mod%i]))%mod;
        Fac[i]=Fac[i-1]*i%mod;
        Fac_inv[i]=Fac_inv[i-1]*inv[i]%mod;
    }
}
```

也可以用欧拉线性筛，但没必要

## 佩尔方程

![img](https://s1.ax2x.com/2018/10/27/5XJmFN.png)















## 因子次幂和函数

$t$次幂$\sigma$函数 $\sigma_t(n)=\sum_{d|n}d^t$

两个特殊情况，t=0,1，分别是**因子数**和**因子和**函数

- 因子个数函数$\sigma_0(n)$
- 因子和函数$\sigma_1(n)$

他们都是积性函数

* 因子个数计算方法即质因子分解后 指数+1 相乘

* 因子和函数：将n质因子分解后，p为素因子，n为指数，有：

![img](https://s1.ax2x.com/2018/09/03/5BlNBX.png)



**使用欧拉筛预处理前maxn项 因子和函数**

**时间复杂度**    $O(n)$  

`help[maxn];`     存每个数最小质因子^指数 如12存2^2  18存2^1  32存2^5

> 补充： 对**因子和函数再求前缀和**可得到函数$f(n)=\sum_{i=1}^{n}\left \lfloor \frac{n}{i} \right \rfloor*i$     也即$g(n)=f(n)-f(n-1)$ 
>
> 类似的，对**因子个数函数再求前缀和**可得到函数$f(n)=\sum_{i=1}^{n}\left \lfloor \frac{n}{i} \right \rfloor$     
>
> 因此可以在$O(\sqrt{n})$的时间内求得这类函数的前缀和，这类分块的思想是杜教筛的基础

```c++
ll g[maxn];//n^(2/3)  g(n)=\sum_{i|n} i
int ans[maxn/10];
int help[maxn];//存每个数最小质因子^指数的值 如12存2^2  18存2^1  32存2^5
bool valid[maxn];
int tot;

void get_prime(int n)
{
    memset(valid,true,sizeof(valid));
    tot=0;
    g[1]=1;
    for(int i=2;i<=n;++i){
        if(valid[i]){
            ans[++tot]=i;
            g[i]=i+1;
            help[i]=i;
        }
        for(int j=1;j<=tot && ans[j]*i<=n;++j){
            valid[ans[j]*i]=false;
            if(i%ans[j]==0){
                help[i*ans[j]]=help[i]*ans[j];
                g[i*ans[j]]=g[i]*ans[j]+g[i/help[i]];
                break;
            }
            else{
                help[i*ans[j]]=ans[j];
                g[i*ans[j]]=g[i]*g[ans[j]];
            }
        }
    }
}
```

因子个数函数类似，也要存个指数


## 欧拉函数

定义：欧拉函数$\varphi(n)$，表示小于或等于$n$的数中与$n$互质的数的数目。

即$\varphi(n)=\sum_{i=1}^{n}{[(n,i)=1]\cdot 1}$ 

一些性质：

* $\varphi(1)=1$     $\varphi(x)是偶数where \ x>2$   
* 若$n$是素数$p$的$k$次幂，$\varphi(n)=p^k-p^{k-1}=(p-1)p^{k-1}$
* 若$m,n$互质，$\varphi(mn)=\varphi(m)\varphi(n)$
* 当$n$为奇数时，有$\varphi(n)=\varphi(2n)$    **可以理解为此时2是2n的最小质因子**
* $\varphi(n)=n*(1-\frac{1}{p_1})*(1-\frac{1}{p_2})*...*(1-\frac{1}{p_k}),p_1,p_2,...,p_k$是$n$的质因子  
* 欧拉定理： $a^{\varphi(m)}\equiv 1 \ (mod \ m)  \quad where \quad   gcd(a,m)=1$    
  * 注意$\varphi(m)$不一定是最小模m为1的指数，但可以证明这些指数都是$\varphi(m)$的因子。因此可以将$\varphi(m)$质因子分解，用每个素因子试除，每个素因子除到模$m$不为1为止（此时要乘回去）。
* $n=\sum_{d|n}{\varphi(d)}$ ，质因数分解乘起来即可证明。**可以看成是欧拉函数和恒等函数的狄利克雷卷积。**
* $\sum_{i=1}^{n}{[(n,i)=1]\cdot i}=\frac{n\cdot\varphi(n)+[n=1]}{2}$
* $\varphi(n)=\sum_{d|n}{\mu(d)\frac{n}{d}}$  ，**由$n=\sum_{d|n}{\varphi(d)}$ 莫比乌斯反演即得**



**几个式子总结：**  

- $\sum_{d|n}\varphi(d)=n$
- $\sum_{d|n}\varphi(\frac{n}{d})*d\ =\ ∑gcd(i, n)(1<=i <=n)\ =\ $$[0,n)$中任选两个数$a,b$，且$a*b$是$n$的倍数的方案数    
- $\sum_{d|n}\sum_{w|d}\varphi(\frac{d}{w})\cdot w=n 乘以 (n的因子数目)$  





**求解欧拉函数单值**

若时间卡的比较紧 先筛选下素数

```c++
//O sqrt(p) 求解欧拉函数
//若时间卡的比较紧 先筛选下素数
ll phi(ll x)
{
    if(x==1) return 1;
    ll res=x;
    for(int i=2;i*i<=x;++i){
        if(x%i==0){
            res-=res/i;
            do{
                x/=i;
            }while(x%i==0);
        }
    }
    if(x>1) res-=res/x;
    return res;
}
```





**欧拉函数线性筛**

$p$为$N$的素因子

若$p^2 | N$，则$\varphi(N)=\varphi(\frac{N}{p})*p$ ；否则$\varphi(N)=\varphi(\frac{N}{p})*(p-1)$

*做素数筛时顺带处理* 

```c++
//欧拉筛法 O(n)
#include<bits/stdc++.h>
using namespace std;

const int maxn=1e7+10;

bool valid[maxn];
int phi[maxn];
int ans[maxn];

void getprime(int n,int &tot,int ans[])
{
    tot=0;
    phi[1]=1;
    memset(valid,true,sizeof(valid));
    for(int i=2;i<=n;++i){
        if(valid[i]){
            tot++;
            ans[tot]=i;
            phi[i]=i-1;//i为素数
        }
        //下面的主角是小于等于i的每个质数
        for(int j=1;(j<=tot) && (i*ans[j]<=n);++j){
            valid[i*ans[j]]=false;
            if(i%ans[j]==0){//ans[j]是i的素因子
                phi[i*ans[j]]=phi[i]*ans[j];
                break;//如果整除就break;
            }
            else phi[i*ans[j]]=phi[i]*(ans[j]-1);
        }
    }
}

int main()
{
    int Count;//素数个数
    getprime(1e7,Count,ans);
    cout<<Count<<endl;
    return 0;
}
```





**反欧拉函数**     洛谷p4780

给定$n$，求$\varphi(x)=n$  的$x$

$n<2^{31}$         若解得$x>=2^{31}$ 或无解则输出-1

**思路：**  枚举$x$的可能质因子$p$，则必须有$n\%(p-1)=0$ ，同时再枚举该质因子的指数，此时要求每有几个$p$（指数），$n$就要能整除$p$几次。  

由于是dfs,时间复杂度有点迷，但感觉再大还是可以做的

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int maxn=1e5+10;

bool valid[maxn];
int ans[maxn];//素数
int tot;
ll all;

void get_prime(int n)
{
    tot=0;
    memset(valid,true,sizeof(valid));
    valid[1]=false;
    for(int i=2;i<=n;++i){
        if(valid[i]){
            ans[++tot]=i;
        }
        for(int j=1;(j<=tot) && (i*ans[j]<=n) ;++j){
            valid[i*ans[j]]=false;
            if(i%ans[j]==0){
                break;
            }
        }
    }
}

bool is_prime(ll x){
    for(int i=2;i<=floor(sqrt(x));++i)
        if(x%i==0) return false;
    return true;
}

ll up;

void dfs(int last,ll num,ll phi){//对num进行分解  last是最后一次选到第几个
    if(num==1){
        all=min(all,phi);
        return ;
    }
    if(num>up && is_prime(num+1)){//如果当前因子num比\sqrt{n}大
        all=min(all,phi*(num+1));
        return ;
    }
    for(int i=last+1;i<=tot && ans[i]<=num;i++)
        if(num%(ans[i]-1)==0){//如果num能整除当前素数-1
            ll num_ = num/(ans[i]-1);//除去
            ll phi_ = phi*ans[i];//搞上
            dfs(i,num_,phi_);
            while(num_%ans[i]==0){//同时phi可以有更多的该素数
                num_/=ans[i];
                phi_*=ans[i];
                dfs(i,num_,phi_);
            }
        }
}

int main()
{
    get_prime(1e5);//1e5很稳
    ll n;
    cin>>n;
    up=floor(sqrt(n));//注意至少要加1
    all=1LL<<31;
    dfs(0,n,1);
    if(all<(1LL<<31)) cout<<all<<endl;//本题的特殊要求
    else cout<<-1<<endl;
    return 0;
}
```





**经典题目**

**例1**    求$∑gcd(i, N)(1<=i <=N)$       [HYSBZ - 2705 ](https://vjudge.net/problem/53982/origin)

枚举哪些数$d$作为$i$和$N$的$gcd$，则$d=gcd(i,N)$，即$1=gcd(i/d,N/d)$。记答案为$f(N)$，有$f(N)=\sum_{d|N}\varphi(\frac{N}{d})*d$为答案。

同时$f(n)$还表示$[0,n)$中任选两个数$a,b$，且$a*b$是$n$的倍数的方案数。（下面例2）

由于是积性函数，素数次幂欧拉值可以O1得到，只剩下质因子分解的时间         **总时间复杂度**  $O(\sqrt{n})$





**例2**         [HDU - 5528 ](https://vjudge.net/problem/271392/origin)      icpc2015长春B

![img](https://s1.ax2x.com/2018/09/04/5BR96K.png)

我们考虑$f(n)$怎么计算  ，$f(n)$等于$n^2$减去是$n$的倍数的方案数

令$h(n)$表示是$n$的倍数的方案数，则$h(n)=\sum_{d|n}\varphi(\frac{n}{d})*d$      如何理解呢？我们去枚举$gcd(a,N)$的值，可知这个值会等于$N$的某个因子，因此我们枚举$n$的因子，则当$gcd(a,N)=d$时，即$gcd(\frac{a}{d},\frac{N}{d})=1 $，$a$有$\varphi(\frac{N}{d})$种取值，由于a只有$N$的因子d，则$b$要包含$N/d$这个因子，那么有多少$b$满足呢？即$N/N/d=d$个 。因此$h(n)=\sum_{d|n}\varphi(\frac{n}{d})*d$ 

所以所求为$g(n)=\sum_{d|n}f(d)=\sum_{d|n}d^2-\sum_{d|n}h(d)$  

对于第二项，质因子分解后，则$\sum_{d|p^k}h(d)=\sum_{d|p^k}\sum_{d'|d}\varphi(\frac{d}{d'})d'$ 

对于$p^k$的因子只有$k+1$个，即$log$级别，因此总共只有质因子分解的时间

**总时间复杂度$O(T*(\frac{\sqrt{n}}{log(n)}+log^2n))$**     注意这里质因子分解时用素数去筛（先预处理出素数） 否则$TLE$

**本题还有一种思路**  我们知道$\sum_{d|n}\varphi(d)=n$，其卷积形式为$\varphi * I=I*\varphi =id$  其中$I$为恒等1函数，$id$为单位函数。本题我们主要求解的是$\sum_{d|n}h(n)=\sum_{d|n}\sum_{w|d}\varphi(\frac{d}{w})\cdot w=\sum_{d|n}(\varphi * id)_{(d)}=I*\varphi *id=(I*\varphi )*id=id*id=\\ \sum_{d|n}id(d)\cdot id(\frac{n}{d})=\sum_{d|n}d\cdot \frac{n}{d}=\sum_{d|n}n=n\cdot \sum_{d|n}1 =n 乘以 (n的因子数目)$     





**例3**   给出$T$组$N,M$，求出$\sum_{i=1}^{N}\sum_{j=1}^Mgcd(i,j)$的值。     $N,M \ 1e6,T\ 1e3$

考虑$n=\sum_{d|n}\varphi(d)$  

则$\sum_{i=1}^{N}\sum_{j=1}^Mgcd(i,j)=\sum_{i=1}^{N}\sum_{j=1}^M  \sum_{d|gcd(i,j)}\varphi(d)$ 

可以对于每个$d$，去考虑$i,j$的贡献，则有$\sum_{i=1}^{N}\sum_{j=1}^M  \sum_{d|gcd(i,j)}\varphi(d)=\sum_d\varphi(d)*(\sum_{1\le i\le N \ and \ d|i}  \sum_{1\le j\le M \ and \ d|j}1) \\  =\sum_d\varphi(d)* \left \lfloor \frac{N}{d}\right \rfloor  \left \lfloor \frac{M}{d}\right \rfloor$

如果直接暴力上式子，时间复杂度是$O(min(N,M))$   

由于出现了下取整符号，考虑进一步优化：分块块

$\left \lfloor \frac{N}{d} \right \rfloor$ 和$\left \lfloor \frac{M}{d}\right \rfloor$在一起分块的区间最多只有$2\left \lfloor \sqrt{n}\right \rfloor+2\left \lfloor \sqrt{m}\right \rfloor$ 段

**总时间复杂度**    $O(1e6+T*(\sqrt{n}+\sqrt{m}))$    

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int maxn=1e6+10;
bool valid[maxn];
int ans[maxn];
ll sum[maxn];
int phi[maxn];
int tot;

void get_prime(int n)
{
    memset(valid,true,sizeof(valid));
    tot=0;
    phi[1]=1;
    for(int i=2;i<=n;++i){
        if(valid[i]){
            tot++;
            ans[tot]=i;
            phi[i]=i-1;
        }
        for(int j=1;j<=tot && ans[j]*i<=n;++j){
            valid[ans[j]*i]=false;
            if(i%ans[j]==0){
                phi[i*ans[j]]=phi[i]*ans[j];
                break;
            }
            else phi[i*ans[j]]=phi[i]*(ans[j]-1);
        }
    }
    for(int i=1;i<=1e6;++i){
        sum[i]=sum[i-1]+phi[i];
    }
}

ll solve(ll up1,ll up2)
{
    ll ans=0;
    ll up=min(up1,up2);
    for(ll l=1,r;l<=up;l=r+1){
        r=min(up1/(up1/l),up2/(up2/l));//这里取最小的右边界
        ans+=(sum[r]-sum[l-1])*(up1/l)*(up2/l);
        //cout<<"l r:"<<l<<" "<<r<<endl;
    }
    return ans;
}

int main()
{
    get_prime(1e6);
    //cout<<phi[6]<<endl;
    //cout<<tot<<endl;
    ll n,m;
    cin>>n>>m;
    //cout<<n<<" "<<m<<endl;
    cout<<solve(n,m)<<endl;
    return 0;
}
```




## 莫比乌斯函数

莫比乌斯函数$\mu(n)$是做莫比乌斯反演的时候一个很重要的系数

![img](https://s1.ax2x.com/2018/09/07/5FH6pO.png)

**一些性质**

* $[n=1]=\sum_{d|n}{\mu(d)}$ ，将$μ(d)$看作是容斥的系数即可证明。 也可以记作$e=\mu * I$，其中$e$为元函数，即在狄利克雷卷积的乘法中与恒等函数互为逆元。 

证明：设$n^*=p_1...p_k$  可知只有当$d|n^*$时，$\mu$值有贡献，所以有 $(n>1)$       
$$
\sum_{d|n}\mu(d)=\sum_{d|n^*}\mu(d)=\sum_{i=0}^kC_k^i(-1)^i=(1-1)^k=0
$$

* $\varphi(n)=\sum_{d|n}{\mu(d)\frac{n}{d}}$   也写作 $\sum_{d|n}{\frac{\mu(d)}{d}}=\frac{\phi(n)}{n}$， **由$n=\sum_{d|n}{\varphi(d)}$ 莫比乌斯反演即得**





**求单值**

$O(\sqrt{n}/log\sqrt{n})$

```c++
short getmob(ll a){
    ll x=a;
    int cnt=0,now=0;
    for(int j=1;1LL*ans[j]*ans[j]<=x && j<=tot;j++){
        now=0;
        if(x%ans[j]==0){
            while(x%ans[j]==0){
                now++;
                if(now>1) return 0;
                x/=ans[j];
            }
            cnt++;
        }
    }
    if(x!=1) cnt++;
    return (cnt&1)?-1:1;
}
```



**递推求解**

$O(nlogn)$ 

```c++
const int maxn=1e6+10;
int mu[maxn];

void get_mu(int n)
{
    for(int i=1;i<=n;++i){
        int target = i==1? 1 :0;
        int delta = target-mu[i];
        mu[i] = delta;
        for(int j=i+i;j<=n;j+=i){
            mu[j]+=delta;
        }
    }
}
```



**线性筛求解**

$O(n)$

```c++
const int maxn=1e7+10;
bool valid[maxn];
short mu[maxn];
int ans[maxn/10];
int tot;

void get_prime(int n)
{
    tot=0;
    mu[1]=1;
    memset(valid,true,sizeof(valid));
    for(int i=2;i<=n;++i){
        if(valid[i]){
            ans[++tot]=i;
            mu[i]=-1;
        }
        for(int j=1;j<=tot&&ans[j]*i<=n;j++){
            valid[i*ans[j]]=false;
            if(i%ans[j]==0){
                mu[i*ans[j]]=0;
                break;
            }
            else{
                mu[i*ans[j]]=-mu[i];
            }
        }
    }
}
```





**例1**     **bzoj2818**    `一道揭示欧拉函数与莫比乌斯函数关系的题`

求$1<=x,y<=N$且$Gcd(x,y)$为**素数**的数对$(x,y)$有多少对.    N 1e7

**方法一**  枚举小于$N$的素数 由于x,y可以交换，不妨设x<y   则求$gcd(x,y)=p$等价于$gcd(x/p,y/p)=1$  枚举素数，对于一个素数，再枚举$y=p,2p,...,kp$ ，即求一个欧拉函数的前缀和。于是先预处理出欧拉函数前缀。

**时间复杂度**，预处理$O(1e7)$，每个询问是$O(N/logN)$ 

**方法二**  枚举素数$p$，令$n=\lfloor\frac{N}{p}\rfloor$，则求
$$
\sum_{i=1}^n\sum_{j=1}^{n}[gcd(i,j)=1]
$$
（其实到这一步直接用欧拉函数就行了，即法1，下面用莫比乌斯函数）即求
$$
\sum_{i=1}^n\sum_{j=1}^{n}\sum_{d|gcd(i,j)}\mu(d)
$$
即
$$
\sum_{d=1}^n\mu(d)*\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}1
$$
即
$$
\sum_{d=1}^n\mu(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{n}{d}\rfloor
$$
由于我们要枚举素数$p$, 即这里的$n=N/p$  ，如果我们纯暴力计算上面和式（先筛出$\mu$），时间复杂度是$O(\sum_{i=1}^N\frac{N}{i},where \ i \ is \ prime)=O(NlogN/logN)\approx O(N)$  

这样复杂度比方法一是要差的。因为方法一是$O(N/logN)$

考虑可不可以进一步优化？  

对于一个$n$，上面和式中，$\lfloor\frac{n}{d}\rfloor$只有$\sqrt{n}$种取值，即一段$d$对应的$\lfloor\frac{n}{d}\rfloor$值是相同的，因此只要有连续一段的$\mu$的和值（预处理前缀和），即可$O(\sqrt n)$求解上面和式。

**因此时间复杂度是（对于每个询问），$O(\sum_{i=1}^n\sqrt{\frac{N}{i}},where \ i \ is \ prime)=O(N/logN)$**   

**时间复杂度同方法一。本题是一道经典的题目，使用了常见的$\varphi,\mu$两种函数求解。**

$O(N/logN)$不是很优秀，考虑进一步优化

**方法三**                 `bzoj2820`

即现在要求$\sum_p\sum_{d=1}^{\frac{N}{p}}\mu(d)\lfloor\frac{\lfloor \frac{N}{p} \rfloor }{d}\rfloor\lfloor\frac{ \lfloor \frac{N}{p} \rfloor}{d}\rfloor=\sum_p\sum_{d=1}^{\frac{N}{p}}\mu(d)\lfloor \frac{N}{pd}\rfloor\lfloor\frac{N}{pd}\rfloor$      

考虑枚举$D=pd$ ，则原式等于$\sum_D\lfloor \frac{N}{D} \rfloor \lfloor \frac{N}{D} \rfloor\sum_{p|D}\mu(\frac{D}{p}) \quad where\ p \ is \ prime$   

令$g(n)=\sum_{p|n}\mu(\frac{n}{p}) \ where \ p \ is \ prime $ ，可以预处理出其前缀和，因此可以分块块。  

**时间复杂度**   $O(1e7+T*O(\sqrt{N}))$

```c++
//O(1e7+T*\sqrt{n})
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int maxn=1e7+10;
int ans[maxn/10];
int mu[maxn];
ll sum[maxn];
bool valid[maxn];
int g[maxn];//sum_{p|n} mu(n/p)
int tot;

void get_prime(int n)
{
    tot=0;
    mu[1]=1;
    g[1]=0;
    memset(valid,true,sizeof(valid));
    for(int i=2;i<=n;++i){
        if(valid[i]){
            ans[++tot]=i;
            mu[i]=-1;
            g[i]=1;
        }
        for(int j=1;j<=tot && ans[j]*i<=n;++j){
            valid[i*ans[j]]=false;
            if(i%ans[j]==0){
                mu[i*ans[j]]=0;
                g[i*ans[j]]=mu[i];//妙啊 展开细算即可  发现只有最小质因子对应的那个非0
                break;
            }
            else{
                mu[i*ans[j]]=-mu[i];
                g[i*ans[j]]=mu[i]-g[i];//妙啊 展开细算即可
            }
        }
    }
    for(int i=1;i<=n;++i){
        sum[i]=sum[i-1]+g[i];
    }
}


ll solve(int up)
{
    ll ans=0;
    for(int l=1,r;l<=up;l=r+1){
        r=up/(up/l);
        // l r
        ll tp=up/l;
        ans+=tp*tp*(sum[r]-sum[l-1]);
    }
    return ans;
}

int main()
{
    get_prime(1e7);
    ios::sync_with_stdio(false);
    int n;
    while(cin>>n) cout<<solve(n)<<endl;
    return 0;
}
```





**例2**  给出$T$组$N,M$，求出$\sum_{i=1}^{N}\sum_{j=1}^Mlcm(i,j)$的值。     $N,M \ 1e7,T\ 1e3$     [HYSBZ - 2154 ](https://vjudge.net/problem/36155/origin)

如果求$gcd$，直接用欧拉函数经典公式换掉分块即可。

而对于$lcm$,原式等价于$\sum_{i=1}^{N}\sum_{j=1}^M\frac{ij}{gcd(i,j)}$ 

我们考虑枚举$d=gcd(i,j)$，则有原式$=\sum_{d}\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\frac{di*dj}{d}\ where \ i \ j \ is \ co-prime=\sum_{d}d*\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}[gcd(i,j)==1]ij$ 

为了方便，我们定义函数$f(n,m)=\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)==1]ij$        **这个式子很经典 经常出题**  

出现了熟悉的$[==1]$,我们用$\mu$换掉，则得$f(n,m)=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{d'|gcd(i,j)}\mu(d')ij$ 

如果从正面考虑（枚举$i,j$），复杂度不行，考虑枚举$d'$，则$f(n,m)=\sum_{d'}\mu(d')*(d'+2d'+...+\lfloor \frac{n}{d'}\rfloor d')*(d'+2d'+...+\lfloor \frac{m}{d'}\rfloor d')=\sum_{d'} \mu(d')*\sum_{i=1}^{\lfloor \frac{n}{d'}\rfloor}id'\sum_{j=1}^{\lfloor \frac{m}{d'}\rfloor}jd'\\ =\frac{1}{4}\sum_{d'}\mu(d')d'^{2}*\lfloor \frac{n}{d'}\rfloor(\lfloor \frac{n}{d'}\rfloor+1)*\lfloor \frac{m}{d'}\rfloor(\lfloor \frac{m}{d'}\rfloor+1)$ 

有了$f(n,m)$的式子，原式$=\frac{1}{4}\sum_dd*\sum_{d'}\mu(d')d'^{2}*\lfloor \frac{\lfloor\frac{N}{d} \rfloor }{d'}\rfloor(\lfloor \frac{\lfloor\frac{N}{d} \rfloor }{d'}\rfloor+1)*\lfloor \frac{\lfloor\frac{M}{d} \rfloor }{d'}\rfloor(\lfloor \frac{\lfloor\frac{M}{d} \rfloor }{d'}\rfloor+1)\\ =\frac{1}{4}\sum_dd*\sum_{d'}\mu(d')d'^{2}*\lfloor \frac{N}{dd'}\rfloor(\lfloor \frac{N }{dd'}\rfloor+1)*\lfloor \frac{M}{dd'}\rfloor(\lfloor \frac{M }{dd'}\rfloor+1)$

这个式子直接去做的话，分两次块块，时间复杂度是$O(n^{\frac{3}{4}})$ 

考虑这里$d$和$d'$的特殊性，由于$d*d'\le min(N,M)$   我们可以枚举$D=d*d'$的值，

则原式$=\frac{1}{4}\sum_{D}\lfloor \frac{N}{D}\rfloor(\lfloor \frac{N }{D}\rfloor+1)*\lfloor \frac{M}{D}\rfloor(\lfloor \frac{M }{D}\rfloor+1)*D*\sum_{d|D}\mu(d)*d$  

设函数$g(n)=n*\sum_{d|n}\mu(d)*d$    可知$g(n)$是积性函数，且可以线性时间筛出。

因此只要一次分块块即可，对于连续的一块，由维护的$g(n)$的前缀和可$O(1)$得到连续的一段$g(D)$的值。

**时间复杂度**    预处理$O(1e7)$     每个询问是$O(\sqrt{N}+\sqrt{M})$  

注：  $g(n) = n\sum_{d|n}{d\mu(d)}$   是一个积性函数，可以用欧拉筛搞出。注意$\mu$很好，当有大于2次幂时贡献为0了

```c++
//先筛g(n)=n* sum_{d|n}d*\mu(d)
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int mod=20101009;
const int ni4=15075757;

const int maxn=1e7+10;
int ans[maxn];
bool valid[maxn];
ll g[maxn];//g(n)=n* sum_{d|n}d*\mu(d)
ll sum[maxn];
int tot;

void get_prime(int n)
{
    memset(valid,true,sizeof(valid));
    //mu[1]=1;
    g[1]=1;
    tot=0;
    for(int i=2;i<=n;++i){
        if(valid[i]){
            ans[++tot]=i;
            g[i]=1LL*i*(1-i)%mod;
        }
        for(int j=1;j<=tot && ans[j]*i<=n;++j){
            valid[i*ans[j]]=false;
            if(i%ans[j]==0){
                g[i*ans[j]]=g[i]*ans[j]%mod;
                break;
            }
            else{
                g[i*ans[j]]=g[i]*g[ans[j]]%mod;
            }
        }
    }
    for(int i=1;i<=n;++i) sum[i]=sum[i-1]+g[i];//这里不模了 不会爆long long 下面再模
}

ll solve(ll up1,ll up2){
    ll ans=0;
    ll up=min(up1,up2);
    for(ll l=1,r;l<=up;l=r+1){
        r=min(up1/(up1/l),up2/(up2/l));
        ll tp1=up1/l;
        tp1=tp1*(tp1+1)%mod;
        ll tp2=up2/l;
        tp2=tp2*(tp2+1)%mod;
        ans=(ans+tp1*tp2%mod*((sum[r]-sum[l-1])%mod)%mod)%mod;
    }
    if(ans<0) ans=ans+mod;//不要忘记了
    return ans*ni4%mod;
}

int main()
{
    ios::sync_with_stdio(false);
    get_prime(1e7+5);
    ll n,m;
    cin>>n>>m;
    cout<<solve(n,m)<<endl;
    return 0;
}
```




## 莫比乌斯反演

**形式一：**

设$F$是$f$的因子和型函数，即
$$
F(n)=\sum_{d|n}{f(d)}
$$
那么对于所有的正整数$n$, 都有下面式子成立
$$
f(n)=\sum_{d|n}{\mu(d)F(\frac{n}{d})}
$$

即已知$F(n)$，我们可以求出$f(n)$                          [○･｀Д´･ ○]



**形式二：**







**通过欧拉函数的莫比乌斯反演进一步理解容斥与反演**

我们知道欧拉函数有：$n=\sum_{d|n}\varphi(d)$ 

由莫比乌斯反演形式一可得$\varphi(n)=\sum_{d|n}\mu(d)*\frac{n}{d}$

我们知道欧拉函数的意义是小于n的数中与n互质的数的个数

那为啥这个$\mu$乘以乘、加一加就能表示欧拉函数了呢？

就是容斥辣，我们考虑$[1,n]$这$n$个数，我们要找的是一些数$k$，有$gcd(k,n)=1$，那显然可能还会有一些数$k$，有$gcd(k,n)>1$   ，那我们要从$n$个数中，**减去$gcd>1$的那些数$k$，这些数有多少呢？**

考虑将$n$质因子分解得到$p_1,p_2,...,p_r$ ，显然有$\frac{n}{p_1}$  个$p_1$的倍数$gcd>1$，同理$\frac{n}{p_2},\frac{n}{p_3},...,\frac{n}{p_r}$ ，将这些个数减去；

但会有重复，比如有一个数$p_1p_2$，在两个地方都减去了，要再加回来，同理所有的两素数都是这样，所以加上$\frac{n}{p_1p_2}$等等两个素数作为分母；

再考虑有一个数$p_1p_2p_3$，考虑一个素数时减去了3次，两个时又加上了3次，因此没有减去这样的数，所以要减去$\frac{n}{p_1p_2p_3}$等等三个素数作为分母；

这个就是**容斥原理**。

再观察$\varphi(n)=\sum_{d|n}\mu(d)*\frac{n}{d}$，由于$\mu$的定义，这里的$d$恰好取便了一个素数、两个素数......的容斥情况，而当$d=1$时，$\mu(1)=1$，即全体个数$n$。







## 积性函数定义

**数论函数：**若$f(x)$的定义域为正整数域，值域为复数域，即$f:\mathbb{Z}^+  \rightarrow \mathbb{C}$ ，则称$f(x)$为数论函数。

**积性函数：**若$f(x)$为数论函数，$f(1)=1$，且$f(x)$满足乘法公式$f(mn)=f(m)f(n)$， 对所有整数$m$与$n$，$gcd(m,n)=1$，则称$f(x)$为积性函数。

**完全积性函数：**若$f(x)$为数论函数，且对任意正整数$m,n$都有$f(mn)=f(m)f(n)$，则称其为完全积性函数。





## 常见的积性函数

* 欧拉函数$\varphi(x)$
* 莫比乌斯函数$\mu(x)$
* $t$次幂$\sigma$函数 $\sigma_t(n)=\sum_{d|n}d^t$
* 因子个数函数$\sigma_0(n)$
* 因子和函数$\sigma_1(n)$



* 刘维尔函数 $\lambda(n)$       定义为将$n$分解后，$n=p_1^{k_1}p_2^{k_2}...p_r^{k_r}$，令$\lambda(n)=(-1)^{k_1+k_2+...+k_r}$。$\lambda(1)=1$  。令$\Omega(n)= k_1+k_2+...+k_r$     则$\lambda(n)=(-1)^{\Omega(n)}$ 。**刘维尔函数的狄利克雷逆变换是莫比乌斯函数的绝对值。**



* 使用刘维尔函数定义新的函数$G(n)$，
  $$
  G(n)=\lambda(d_1)+\lambda(d_2)+...+\lambda(d_r)=\sum_{d|n}\lambda(d)
  $$
  **$G(n)$也是积性函数。**其满足下面的性质
  $$
  \sum _{{d|n}}\lambda (d)={\begin{cases}1&{\text{if }}n{\text{ is a perfect square,}}\\0&{\text{otherwise.}}\end{cases}}
  $$














* **元函数**$e(n)=[n=1]$ ，**狄利克雷卷积中的乘法单元**，完全积性
* 恒等函数$I(n)=1$，完全积性
* 单位函数$id(n)=n$，完全积性
* 幂函数$id^k(n)=n^k$，完全积性





**刘维尔函数与莫比乌斯函数**
$$
\left\{\begin{matrix}
\sum_{d|n}\lambda(d)\mu(\frac{n}{d}) =1  ,\quad n=k^2 \\ 
\sum_{d|n}\lambda(d)\mu(\frac{n}{d}) =0,\quad  n\neq k^2 
\end{matrix}\right.
$$





## 不是很常见的积性函数

*   $g(n) = n\sum_{d|n}{d*\mu(d)}$   是一个积性函数，可以用欧拉筛搞出。注意$\mu$很好，当有大于2次幂时贡献为0了
*   $f(n)=n\sum_{d|n}d*\varphi(d)=-n+2*\sum_{i=1}^nLCM(n,i)$    $f(p^{k+1})=p*f(p^k)+p^{3(k+1)}-p^{3k+2}=p^3f(p^{k})-p^{k+1}(p-1)$，注意有减法，因此可能要维护一下每个数的最小质因子的指数，也可以$O(n)$





## “作用在因子上”

定义函数$F(n)=\sum_{d|n}f(d)$

> 若$f(x)$是积性函数，则$F(x)$也是积性函数；反之，若$F(x)$为积性函数，则$f(x)$也是积性函数。

**证明：**    $f(x)$是积性函数，对于$gcd(m,n)=1$,要证明$F(mn)=F(m)F(n)$。设：
$$
d_1,d_2,...,d_r是n的因数\\
e_1,e_2,...,e_s是m的因数
$$
$m,n$互质，则$mn$的因子就是上面$r$个因子和$s$个因子两两相乘得到的，共$r*s$个。

又$d_i$和$e_j$互质，则$f(d_ie_j)=f(d_i)f(e_j)$  ，则
$$
\begin{align}
F(mn)&=f(d_1e_1)+f(d_1e_2)+...+f(d_1e_s)+...+f(d_r)f(e_1)+...+f(d_r)f(e_s) \\& = [f(d_1)+f(d_2)+...+f(d_r)]*[f(e_1)+f(e_2)+...+f(e_s)] \\ 
&=F(n)*F(m)
\end{align}
$$
证毕。

反之，当$F(n)$为积性函数时，证明类似。

其**狄利克雷卷积**形式为$\varphi * I=I*\varphi =id$  其中$I$为恒等1函数，$id$为单位函数。





## 狄利克雷卷积

设$f,g$为两个数论函数，则满足$h(n)=\sum_{d|n}f(d)g(\frac{n}{d})$的函数称为$f$与$g$的狄利克雷卷积函数。也可以理解为$h(n)=\sum_{ij=n}f(i)g(j)$ 。**两个积性函数的卷积仍为积性函数。**   狄利克雷卷积满足交换律和结合律，对加法满足分配律。                

多个函数的狄利克雷卷积类似。$\sum_{ijkl..z=n}f_1(i)f_2(j)f_3(k)...f_{*}(z)$





**例题1**    http://codeforces.com/problemset/problem/757/E

![img](https://s1.ax2x.com/2018/09/05/5Bq4di.png)

**满足$pq=n$且$gcd(p,q)=1$的二元组个数是多少呢**？

显然是$2^{w(n)}$个，其中$w(n)$是不同的素因子的数目

那么$f_{r+1}(n)=\sum_{uv=n}\frac{f_r(u)+f_r(v)}{2}$如何计算呢？

$f_{r+1}(n)=\sum_{uv=n}\frac{f_r(u)+f_r(v)}{2}=\sum_{d|n}f_r(d)$ 

由于$r\ 1e6$，询问又有$1e6$，那我们不可能暴力搞。

我们知道$f_r(n)$是积性函数  问题转为求解$f_r(p^k)$

由于$f_r(p^k)=\sum_{i=0}^{i=k}f_{r-1}(p^i)$

由于任意p，k>=1，有$f_0(p^k)=2$，因此$f_r(p^k)$的值和$p$无关。预处理所有的$r,k$组合即可。k是log级别的。

**时间复杂度**  $O(rlogn+T*(\frac{\sqrt{n}}{log1e3}))$   





**例题2**

$T$个$N$，依次计算$\sum_{a=1}^{N}\sum_{b=1}^NLCM(a,b)$             $N,T\le 10^6$

前面我们解过$\sum_{a=1}^{N}\sum_{b=1}^MLCM(a,b)$   复杂度可以是$T*O(\sqrt{N}+\sqrt{M})$

显然解这题是不够的

考虑本题，如果直接令一个函数$f(N)=\sum_{a=1}^{N}\sum_{b=1}^NLCM(a,b)$  

其是不是积性函数呢？

可惜不是，**但这个函数$f(n)=-n+2*\sum_{i=1}^nLCM(n,i)$是积性函数。**

为啥长这样(⊙o⊙)… 其实这样很美，因为$\sum_{i=1}^Nf(i)$即为本题所求

但$f(n)$目前这个样子还是不知道怎么搞

我们化简一下

设$gcd(n,i)=d$，则$f(n)=-n+2\sum_{i=1}^n\frac{ni}{d}=-n+2n\sum_{d|n}\sum_{i\le n \ \& \ gcd(i,n)=d}\frac{i}{d}=-n+2n\sum_{d|n}\sum_{k\le \frac{n}{d}\ \& \ gcd(k,\frac{n}{d})=1}k$

$=-n+2n\sum_{d|n}\sum_{k\le d\  \& \ gcd(k,d)=1}k=-n+2n(\sum_{d|n\ \& \ d>1}\frac{d\varphi(d)}{2}+1)=n\sum_{d|n}d\varphi(d)$ 

即$f(n)=-n+2*\sum_{i=1}^nLCM(n,i)=n\sum_{d|n}d\cdot \varphi(d)$ 是积性函数。

所以，只要筛出这个积性函数，就可以$O(1)$回答一个询问。

如何去筛这个函数呢？考虑一个数$p^k$，若它新出现一个质因子变为$p^kq$，则函数值$f(p^kq)=f(p^k)f(q)$，若从$p^k$变为$p^{k+1}$，则$f(p^{k+1})=p*f(p^k)+p^{3(k+1)}-p^{3k+2}=p^3f(p^{k})-p^{k+1}(p-1)$   ， 后面的部分是$p\varphi(p^{k+1})$，因此欧拉筛搞一搞即可。 （因为有减法，而不仅仅是乘法，可能要维护一下每个数最小质因数指数幂后的数）

总时间复杂度 $O(1e6+T)$

> 另外一种形式 ：   $\sum_{i=1}^Nf(i)=\sum_{i=1}^Ni\sum_{d|i}d \varphi(d) \\= \sum_{d=1}^Nd\varphi(d)\sum_{k=1}^{\frac N d}kd  \\= \sum_{d=1}^Nd^2\varphi(d)\sum_{k=1}^{\frac N d}k \\    = \sum_{k=1}^N k\sum_{d=1}^{\lfloor\frac N k\rfloor}\phi(d)d^2    \\= \sum_{i=1}^N i\sum_{d=1}^{\lfloor\frac N i\rfloor}\phi(d)d^2 (用i代替符号k)$     

如果$f(x)=\varphi(x)x^2,S(n)=\sum_{i=1}^nf(i)$  可以做杜教筛，则上面的式子也行，不影响时间复杂度 $O(n^{\frac 2 3})$

**这一点给予我们启发，如果出现$\sum_{i=1}^N\sum_{d|i}$的形式，直接对后面杜教筛可能不太好搞**

**我们可以尝试调换贡献的枚举（这里枚举$i$是$d$的多少倍），变换为$\sum_{i=1}^N\sum_{d=1}^{\lfloor \frac n i \rfloor}f(d)$的形式，对后面一个$\sum$做杜教筛，而前面的$\sum$不影响时间复杂度。**



## 积性函数前缀和

**一些定义和性质**

![img](https://s1.ax2x.com/2018/09/05/5BnMYO.png)

$\left \lceil \frac{n}{i} \right \rceil$ 为什么只有$O(\sqrt{n})$种取值呢？若$i<\sqrt{n}$ 则由于$i$只有$\sqrt{n}$种取值，所以$\left \lceil \frac{n}{i} \right \rceil$只有$\sqrt{n}$种取值；若$i>\sqrt{n}$  ，则$\left \lceil \frac{n}{i} \right \rceil<\sqrt{n}$  ，所以 $\left \lceil \frac{n}{i} \right \rceil$也只有$\sqrt{n}$种取值 。



**一些常用复杂度计算**

* $\sum_{i=1}^{n}\frac{n}{i}=O(nlogn)$  

* $\sum_{i=1}^{n^x}\sqrt{\frac{n}{i}}=n^{(\frac{1}{2}+\frac{1}{2}x)}$         例如$\sum_{i=1}^{\sqrt{n}}\sqrt{\frac{n}{i}}=n^{\frac{3}{4}}$     ，   $\sum_{i=1}^{n}\sqrt{\frac{n}{i}}=n$   ，$\sum_{i=1}^{n^{\frac{1}{3}}}\sqrt{\frac{n}{i}}=n^{\frac{2}{3}}$





**前缀和**

给出一个积性函数$f(x)$，求$\sum_{i=1}^nf(i)$

通常，$f(p^k)$可以比较容易的由$f(p^{k-1})$等值递推出来，其他项可以直接由积性函数的性质由$f(x)=f(d)*f(\frac{x}{d})$得到。因此很多积性函数都可以在欧拉筛的过程中顺便递推出前$n$项的值，时间复杂度$O(n)$。





## 低于线性时间求前缀和

**例题1**  设$\sigma(n)$为因子和函数，现在要求解$\sum_{i=1}^n\sigma(i)$ 

一种简单的思考方法，考虑函数$f(n)=\sum_{i=1}^ni*\lfloor \frac{n}{i}\rfloor$  

发现$f(n)-f(n-1)=\sum_{i=1}^ni*(\lfloor \frac{n}{i}\rfloor-\lfloor \frac{n-1}{i}\rfloor)=\sigma(n)$  

因此$f(n)$为我们所求，分块块即可$O(\sqrt{n})$

> 因此我们也可以线性筛出函数$f(1...n)=\sum_{i=1}^ni*\lfloor \frac{n}{i}\rfloor$ 





**例题2**    线性筛出函数$f(n)=\sum_{i=1}^n\left \lceil \frac{n}{i}  \right \rceil$ ，即求$f(1),f(2),...,f(n)$   

注意**下取整和上取整的不同**，下取整的**差分减一**对应**下标减一的**因子个数函数，即$f(n)-f(n-1)=\tau(n-1)+1$

因此先预处理出因子个数函数，再移位+1，最后求前缀和

```c++
void init_f(int n)
{
    //f(n)=sum_{i=1}^{n} \ceil(n/i)
    // sigma_0后移一位并加1 对应f
    //处理完之后全部加1并后移一位  再做一次前缀和就是f
    f[0]=0;
    for(int i=1;i<=n;++i){
        f[i]=(sigma_0[i-1]+1);
    }
    for(int i=1;i<=n;++i){
        f[i]=(f[i]+f[i-1])%mod;
    }
}
```





**例题3**     https://www.oj.swust.edu.cn/contest/problem/1253-G   18四川省赛G

求$ans =\sum^n_{i=1}\sum^i_{j=1} (n\  mod (i \times j))$          $1 ≤ n ≤ 10^{11}$

**解法一**

首先写作$\sum^n_{i=1}\sum^i_{j=1} (n-\left \lfloor \frac{n}{ij} \right \rfloor*ij)=\sum^n_{i=1}\sum^i_{j=1} n-\sum^n_{i=1}\sum^i_{j=1}\left \lfloor \frac{n}{ij} \right \rfloor*ij $      

对于$\sum^n_{i=1}\sum^i_{j=1} n$不用说了，对于$\sum^n_{i=1}\sum^i_{j=1}\left \lfloor \frac{n}{ij} \right \rfloor*ij =\sum^n_{i=1}i*\sum^i_{j=1}\left \lfloor\frac{\left \lfloor \frac{n}{i} \right \rfloor} {j}\right \rfloor*j$ 

对于第二维，所求是j∈$[1,i]$ 我们这里求$[1,n]$ 由对称性可知$[1,i]$的两倍减去$[i=j]$的情况即为所求

所以现在目标是$\sum^n_{i=1}i*\sum^n_{j=1}\left \lfloor\frac{\left \lfloor \frac{n}{i} \right \rfloor} {j}\right \rfloor*j$ 

由于$\left \lfloor \frac{n}{i} \right \rfloor$ 只有$O(\sqrt{n})$种取值，我们枚举$\left \lfloor \frac{n}{i} \right \rfloor$的值，对应一段$i$区间，可知对于这一段$i$，第二维值是相同的。

而对于第二维的计算相同，都是分块思想。所以写一个solve函数用于求解$f(n)=\sum_{i=1}^{n}\left \lfloor \frac{n}{i} \right \rfloor*i$ 即可。 

时间复杂度  $O(\sum_{i=1}^{\sqrt{n}}\sqrt{\frac{n}{i}})=O(n^{\frac{3}{4}})$  （只有$O(\sqrt{n})$种取值）         

**TLE**      1e11大概要跑37s

**解法二**     （常见套路）

定义$g(n)=f(n)-f(n-1)=\sum_{i=1}^{n}i* (\left \lfloor \frac{n}{i}\right \rfloor-\left \lfloor \frac{n-1}{i} \right \rfloor)=\sum_{d|n}d$    

对于$g(n)$，即一个数的因子和，我们可以$O(n)$求解出其前$n$项，对于本题$n \ 1e11$ ，我们处理出$g$的前$n^{\frac{2}{3}}$项 ，然后求个前缀和就得到了$f(n)$ ，这一部分的时间复杂度是$O(n^\frac{2}{3})$    

所以对于$\sum^n_{i=1}i*\sum^n_{j=1}\left \lfloor\frac{\left \lfloor \frac{n}{i} \right \rfloor} {j}\right \rfloor*j$，当$\left \lfloor \frac{n}{i}\right \rfloor<n^\frac{2}{3}$时，可以$O(1)$得到第二层结果。当$\left \lfloor \frac{n}{i}\right \rfloor>n^{\frac{2}{3}}$时，使用原先的方法求解，这一部分的时间复杂度是$O(\sum_{i=1}^{n^\frac{1}{3}}\sqrt{\frac{n}{i}})=O(n^\frac{2}{3})$

**总时间复杂度  $O(n^\frac{2}{3})$**       1e11大概要跑5s

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 lll;
const int mod=1e9+7;

inline lll cal(lll l,lll r)
{
    return (l+r)*(r-l+1)/2;
}
 
inline lll solve(ll up)//solve \sum_{i=1}^{n} up/i *i;
//显然只有i<=up时有贡献
{
//    num++;
//    if(num%10000==0) cout<<clock()<<endl;
    lll res=0;
    for(ll l=1,r;l<=up;l=r+1){
        r=up/(up/l);
        res=(res+up/l*cal(l,r));
    }
    return res;
}
 
inline void write(__int128 x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
 
//lll help1[maxn];//solve f(n/1) f(n/2) f(n/3) f(n/\sqrt(n))
//lll help2[maxn];//solve 1 2 3  \sqrt{n}
const int maxn=21550000;
ll g[maxn];//n^(2/3)  g(n)=\sum_{i|n} i
lll f[maxn];//sum_{i=1}^{n} [n/i]*i  
int ans[maxn/10];
int help[maxn];//存每个数最小质因子^指数 如12存2^2  18存2^1  32存2^5
bool valid[maxn];
int tot;

void get_prime(int n)
{
    memset(valid,true,sizeof(valid));
    tot=0;
    g[1]=1;help[1]=1;
    for(int i=2;i<=n;++i){
        if(valid[i]){
            ans[++tot]=i;
            g[i]=i+1;
            help[i]=i;
        }
        for(int j=1;j<=tot && ans[j]*i<=n;++j){
            valid[ans[j]*i]=false;
            if(i%ans[j]==0){
                help[i*ans[j]]=help[i]*ans[j];
                g[i*ans[j]]=g[i]*ans[j]+g[i/help[i]];
                break;
            }
            else{
                help[i*ans[j]]=ans[j];
                g[i*ans[j]]=g[i]*g[ans[j]];
            }
        }
    }
}
 
 
int main()
{
    get_prime(maxn);
    f[0]=0;
    for(int i=1;i<maxn;++i) f[i]=f[i-1]+g[i];
    //cout<<clock()<<endl;
    //freopen("in.txt","r",stdin);
    int t;
    cin>>t;
    while(t--)
    {
        ll n;
        cin>>n;
        lll ans1=0;
        for(ll l=1,r;l<=n;l=r+1){
            r=n/(n/l);
            ll tp=n/l;
            if(tp<maxn) ans1+=f[tp]*cal(l,r);
            else ans1+=solve(tp)*cal(l,r);
        }
        lll ans2=0;//i=j
        for(ll i=1;i*i<=n;++i){
            ll tp=i*i;
            ans2+=n/tp*tp;
        }
        ans1+=ans2;
        assert(ans1%2==0);
        ans1/=2;
        ans1=((lll)n)*n*(n+1)/2-ans1;
        write(ans1);
        cout<<endl;
    }
    return 0;
}
```



## 杜教筛

设$S(n)=\sum_{i=1}^nf(i)$，下面将求解$S(n)$的过程一般化

任意数论函数$g$，设$h=f*g$，有$\sum_{i=1}^nh(i)=\sum_{i=1}^ng(i)S(\lfloor \frac{n}{i}\rfloor)$   （改变计数方式易得）

从右式分出一个$i=1$，移项可得$g(1)S(n)=\sum_{i=1}^nh(i)-\sum_{i=2}^ng(i)S(\lfloor \frac{n}{i}\rfloor)$

**如果我们可以$O(\sqrt{n})$计算$\sum_{i=1}^nh(i)$，$O(1)$计算$g$的前缀和，就可以快速把问题递归为同类子问题**，时间复杂度为$O(\sum_{i=1}^{\sqrt{n}}\sqrt{\frac{n}{i}})=O(n^{\frac{3}{4}})$       （具体计算这里略去）

如果$f$有一些比较好的性质，比如是积性函数，我们可以用欧拉筛求出前$n^{\frac{2}{3}}$项，更后面的项再递归，时间复杂度为$O(n^{\frac{2}{3}})$ 



* 会卡map
* 一个记忆化的技巧是，由于我们要求解的始终是$S(n除去一些数)$，因此我们可以开一个数组，比如$p[]$，$p[i]$的地方存储$S(\frac{n}{i})$的值，显然由于我们预处理了$i<n^{\frac{2}{3}}$的情况，则$p$数组的大小只有$n^{\frac{1}{3}}$大小。

* 如果出现$\sum_{i=1}^N\sum_{d|i}$的形式，直接对后面杜教筛可能不太好搞。我们可以尝试调换贡献的枚举（这里枚举$i$是$d$的多少倍），变换为$\sum_{i=1}^N\sum_{d=1}^{\lfloor \frac n i \rfloor}f(d)$的形式，对后面一个$\sum f$做杜教筛，而前面不影响复杂度(分$i<n^{\frac 1 3}$和$>$考虑)。如例2。

* $f(x)=\varphi(x)x^k$都是可以搞的,即$h(x)=x^{k+1},g(x)=x^k$





**例1 **    `bzoj 3944`

求$\sum_{i=1}^n\varphi(i)和\sum_{i=1}^n\mu(i),\quad n \ 1e9$   多组       

考虑有没有函数$g$，这个函数易于计算前缀和，且和$\varphi$狄利克雷卷积后的函数也较易于计算前缀和

对于欧拉函数，这是显然存在的，即$g(n)=1$

设$S(n)=\sum_{i=1}^n\varphi(i),g(n)=1,h=\varphi * g$

$g(1)S(n)=\sum_{i=1}^nh(i)-\sum_{i=2}^ng(i)S(\lfloor \frac{n}{i}\rfloor)$ 

我们知道$h(n)=n$

带入$g,h$的值后，有$S(n)=\sum_{i=1}^ni-\sum_2^nS(\lfloor \frac{n}{i}\rfloor)$

用欧拉筛求出欧拉函数的前$n^{\frac{2}{3}}$，求前缀和得到$S$的前$n^{\frac{2}{3}}$项。$\lfloor \frac{n}{i}\rfloor$ 较大时递归计算，总时间复杂度$O(n^\frac{2}{3})$



对于 $梅滕斯函数(Mertens)=\sum_{i=1}^n\mu(i)$   

同样的，我们寻找函数$g$，有$h=\mu*g$  其中$g$可以$O(1)$计算前缀和

我们知道$\mu$的一个性质是$\sum_{d|n}\mu(d)=[n==1]$  

它的卷积形式是$e=\mu * id $

因此$g(1)S(n)=\sum_{i=1}^nh(i)-\sum_{i=2}^ng(i)S(\lfloor \frac{n}{i}\rfloor)$

化简后得$S(n)=1-\sum_{i=2}^nS(\lfloor \frac{n}{i}\rfloor)$  

> 注意记忆化的技巧
>
> 注意取模

```c++
#include<bits/stdc++.h>
#define pb push_back
#define mp make_pair
#define bit(a,b) ((a>>b)&1) //from 0
#define all(x) (x).begin(),(x).end()
using namespace std;
typedef long long ll;
int debug_num=0;

const int maxn=5e6+10;
bool valid[maxn];
int ans[maxn/10];
ll phi[maxn];
int mu[maxn];
const int maxm=(1LL<<32)/maxn;
ll help1[maxm];
int help2[maxm];
bool vis[maxm];
int tot,up,m;

void get_prime(int n)
{
    memset(valid,true,sizeof(valid));
    tot=0;
    mu[1]=phi[1]=1;
    for(int i=2;i<=n;++i){
        if(valid[i]){
            ans[++tot]=i;
            mu[i]=-1;
            phi[i]=i-1;
        }
        for(int j=1;j<=tot && ans[j]*i<=n;++j){
            int tp=ans[j]*i;
            valid[tp]=false;
            if(i%ans[j]==0){
                mu[tp]=0;
                phi[tp]=phi[i]*ans[j];
                break;
            }
            else{
                mu[tp]=-mu[i];
                phi[tp]=phi[i]*(ans[j]-1);
            }
        }
    }
    for(int i=1;i<=n;++i){
        phi[i]+=phi[i-1]; mu[i]+=mu[i-1];
    }
}

ll get_phi(ll n)
{
    return (n<=up) ? phi[n] : help1[m/n] ;
}


ll get_mu(ll n)
{
    return (n<=up) ? mu[n] : help2[m/n] ;
}


void solve(ll n)
{
    int t;
    if(n<=up || vis[t=m/n]) return ;
    vis[t]=true;
    help1[t]=n*(n+1)/2; help2[t]=1;
    for(ll l=2,r;l<=n;l=r+1){
        r=n/(n/l);
        solve(n/r);
        help1[t]-=(r-l+1)*get_phi(n/r);
        help2[t]-=(r-l+1)*get_mu(n/r);
    }
}

int main()
{
    //freopen("in.txt","r",stdin);
    up=maxn-10;
    get_prime(up);
    //cout<<clock()<<endl;
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        m=n;
        if(n<=up) cout<<phi[n]<<" "<<mu[n]<<endl;
        else{
            memset(vis,false,sizeof(vis));
            solve(n);
            cout<<help1[1]<<" "<<help2[1]<<endl;
        }
    }
    return 0;
}
```





**例2**    `51nod1237`

求
$$
\sum_{i=1}^{n}\sum_{j=1}^{n}gcd(i,j)
$$
解答：
$$
ans=2\sum_{i=1}^n\sum_{j=1}^igcd(i,j)-\frac {n(n+1)}{ 2}=2\sum_{i=1}^n\sum_{d|i}\varphi(\frac i d)d-\frac {n(n+1)}{ 2} \\ =2\sum_{d=1}^nd\sum_{k=1}^{\lfloor \frac n d \rfloor}\varphi(k)  -\frac {n(n+1)}{ 2}
$$
这里对第一维分块不影响复杂度，只要对第二维做杜教筛即可  $n=\varphi * I$





**例3 **   `51nod 1238` 

求
$$
ans=\sum_{i=1}^n\sum_{j=1}^n LCM(i,j)    \quad  n \ 1e10
$$
解答：
$$
\begin{equation}
ans=\sum_{i=1}^n\sum_{j=1}^n [i,j]\\
=2\sum_{i=1}^n\sum_{j=1}^i [i,j]-\frac{n(n+1)}2\\
Let\space s(n)=\sum_{i=1}^n\sum_{j=1}^i [i,j],f(n)=\sum_{i=1}^n [i,n]\\
f(n)=\sum_{i=1}^n [i,n]\\
=\sum_{i=1}^n\frac{in}{(i,n)}\\
=n\sum_{i=1}^n\frac i{(i,n)}\\
=n\sum_{d|n}\sum_{i=1}^n[(i,n)=d]\frac i d\\
=n\sum_{d|n}\sum_{i=1}^{\frac n d}[(i,\frac n d)=1]i\\
=n\sum_{d|n}\sum_{i=1}^{d}[(i,d)=1]i(此处由于因子的对称性)\\
=n\sum_{d|n}\frac{\phi(d)d+[d=1]}2\\
=n\frac{1+\sum_{d|n}\phi(d)d}2\\
s(n)=\sum_{i=1}^n f(i)\\
=\frac{\sum_{i=1}^n i(1+\sum_{d|i}\phi(d)d)}2\\
=\frac{\sum_{i=1}^n i+\sum_{i=1}^n i\sum_{d|i}\phi(d)d}2\\
=\frac{\frac{n(n+1)}2+\sum_{i=1}^n i\sum_{d|i}\phi(d)d}2\\
=\frac{\frac{n(n+1)}2+\sum_{d=1}^n\phi(d)d\sum_{d|i}i}2\\
=\frac{\frac{n(n+1)}2+\sum_{d=1}^n\phi(d)d^2\sum_{i=1}^{\lfloor\frac n d\rfloor}i}2\\
=\frac{\frac{n(n+1)}2+\sum_{i=1}^n i\sum_{d=1}^{\lfloor\frac n i\rfloor}\phi(d)d^2}2\\
ans=2s(n)-\frac{n(n+1)}2\\
=\sum_{i=1}^n i\sum_{d=1}^{\lfloor\frac n i\rfloor}\phi(d)d^2\\
Let \space h(d)=\phi(d)d^2,g(n)=\sum_{d=1}^nh(d)\\
n=\sum_{d|n}\phi(d)\\
n^3=\sum_{d|n}\phi(d)n^2\\
=\sum_{d|n}\phi(d)d^2(\frac n d)^2  （到这里可以看到是n^2和n^3了）\\ 
=\sum_{d|n}h(d)(\frac n d)^2\\
\sum_{i=1}^n i^3=\sum_{i=1}^n\sum_{d|i}h(d)(\frac i d)^2\\
=\sum_{d=1}^n h(d)\sum_{d|i}(\frac i d)^2\\
=\sum_{d=1}^n h(d)\sum_{i=1}^{\lfloor\frac n d \rfloor}i^2\\
=\sum_{i=1}^n i^2\sum_{d=1}^{\lfloor\frac n i\rfloor}h(d)\\
=\sum_{i=1}^n i^2 g(\lfloor\frac n i\rfloor)\\
g(n)=\sum_{i=1}^n i^3-\sum_{i=2}^ni^2 g(\lfloor\frac n i\rfloor)
\end{equation}
$$

可以看到杜教筛的形式，这里对第一维分块不影响复杂度，只要对第二维做杜教筛即可。





**例4**    











## Extended Eratosthenes Sieve   [参考链接](https://www.spoj.com/problems/TEES/tdsourcetag=s_pctim_aiomsg)

给出一个积性函数(一些非积性函数也可以搞一搞)$f$，且$f(p)$为关于$p$的多项式。求$S(n)=\sum_{i=1}^nf(i)$

$\forall  \ 2\le i\le n$，我们可以将$i$分为两类

* 最大质因子的幂次=1，则其次大质因子$< \sqrt{n}$
* 最大质因子的幂次$>$1 ，则其最大质因子$\le \sqrt{n}$

初始化$S(n)=f(1)$ 

**枚举所有质因子$\le\sqrt{n}$的数$k$，设其最大质因子为$L$，则$S(n)+=f(k)\cdot\sum_{L<p\le \frac n k}f(p) \quad p \ is \ prime $，此时每个$k\cdot p$都对应第一类数；**

**另外，若$k$的最大质因子次幂$>1$，$S(n)+=f(k)$，此时$k$就是一个第二类数。**

伪代码如下：	

![img](https://s1.ax2x.com/2018/10/27/5XJpHY.png)



* 如果我们$dfs$质因子来得到每个$k$，通常可以由积性函数的定义与性质简单地计算出$f(k)$。另外需要注意的是，如果$L>\frac n k$，则继续递归对答案的贡献为0，此时需要及时break，否则影响时间复杂度
* 如果我们可以$O(1)$地求出$\sum_{L<p\le \frac n k}f(p)$，那么上面过程的时间复杂度是$O(满足kL< n的k的个数)$，当$n\le 10^{13}$时，时间复杂度为$O(\frac {n^{\frac 3 4}}{ log n})$ 

* 设$g(i)=\sum_{1\le p\le i}f(p)$   ，现在问题只剩下了求$\sum_{L<p\le \frac n k}f(p)=g(\lfloor \frac n k\rfloor)-g(L)$   。 由于$\lfloor \frac n k\rfloor$只有$O(\sqrt{n})$种，$L\le \sqrt{n}$也只有$O(\sqrt{n})$种，因此我们只需要计算$g$的$O(\sqrt{n})$项。

* 在题设里提到了$f(p)$是一个关于$p$的多项式，即$f(p)=\sum a_ip^{k_i} \quad p \ is \ prime$ ，我们对于每个$i$，假设$f(p)=p^{k_i}$，最后乘上系数累加就可以得到$ans$
* 现在的问题是求$g(i)=\sum_{1\le p\le i}f(p)$，注意这里$p$是素数，因此$f$的非质数项的结果是不影响答案的，我们强行规定$f(n)=n^{k_i}$使得$f$成为一个完全积性函数。



计算$g(i)$的伪代码：

![img](https://s1.ax2x.com/2018/10/27/5XJsui.png)



* 对于每个我们可能用到的$g(i)$，我们只会在遍历不超过$\sqrt{n}$的质数时访问到，因此每个$i$贡献的时间复杂度为$O(\frac {\sqrt{i} }{log\sqrt{i}})=O(\frac {\sqrt{i} }{logi})$  



* ![img](https://s1.ax2x.com/2018/10/27/5XJuty.png)





**例题1**  [DIVCNTK](https://www.spoj.com/problems/DIVCNTK/)

定义$\sigma(n)=n的因子数$  ，求$\sum_{i=1}^n\sigma(i^k)  \ mod  \ 2^{64}   \quad \ n,k \ 1e10$        

```c++
//SPOJ  DIVCNTK - Counting Divisors (general)
//Author : Feynman1999   9.27.2018
//f(1)=1
//f(p)=k+1
//f(p^e)=ek+1
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long u64;
u64 n,M,k;
//pre预处理后是2~i的p^0的和  p是素数
//hou是2~n/i的p^0的和
//同理，一个题目可能出现p^1 p^2等需要维护
vector<u64> pre,hou,primes;

// 这里res是n/枚举的数
u64 dfs(u64 res, int last, u64 f){
    //最大质因子是prime[last-1] 但将1放在外面值显然一样
    u64 t=(res > M ? hou[n/res] : pre[res])-pre[primes[last]-1];
    u64 ret= t*f*(k+1);//这里需修改
    for(int i=last;i<(int) primes.size();++i){
        int p = primes[i];
        if((u64)p*p > res) break;
        for(u64 q=p,nres=res,nf=f*(k+1);q*p<=res;q*=p){//nf需修改
            ret += dfs (nres/=p,i+1,nf);//枚举更大的数
            nf += f*k;//继续枚举当前素数，指数大于1时，指数每加1，nf+=f*k  ,k是系数
            ret += nf;//指数大于1时，记上贡献
        }
    }
    return ret;
}
u64 solve(u64 n){
    M=sqrt(n);
    pre.clear();pre.resize(M+1);
    hou.clear();hou.resize(M+1);
    primes.clear();primes.reserve(M+1);
    for(int i=1;i<=M;++i){
        pre[i]=i-1;
        hou[i]=n/i-1;
    }
    for(int p=2;p<=M;++p){
        if(pre[p]==pre[p-1]) continue;
        primes.push_back(p);
        const u64 q=(u64)p*p,m=n/p,pnt=pre[p-1];
        const int mid=M/p;
        const int End=min((u64)M,n/q);
        for(int i=1;i<=mid;++i) hou[i]-=hou[i*p]-pnt;
        for(int i=mid+1;i<=End;++i) hou[i]-=pre[m/i]-pnt;
        for(int i=M;i>=q;--i) pre[i]-=pre[i/p]-pnt;
    }
    primes.push_back(M+1);
    return n>1 ? 1+dfs(n,0,1) : 1;
}
int main()
{
    //freopen("in.txt","r",stdin);
    ios::sync_with_stdio(false);
    int t;
    cin>>t;
    while(t--)
    {
        cin>>n>>k;
        cout<<solve(n)<<endl;
    }
    return 0;
}
```





**例题2  **    [神犇和蒟蒻](https://www.lydsy.com/JudgeOnline/problem.php?id=4916)     

![img](https://s1.ax2x.com/2018/10/27/5XJJ3X.png)

`1<=N<=1E9`   答案mod 1e9+7

显然A=1，我们只要计算B

```c++
//phi(1^2)=1
//phi(p^2)=p^2-p
//phi((p^e)^2)=phi((p^{e-1})^2)*p*p;
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
const int ni6=166666668;
const int ni2=500000004;
ll n,M;
vector<int> pre[3],hou[3],primes;

inline int add(const int x, const int v) {
    return x + v >= mod ? x + v - mod : x + v;
}
inline int dec(const int x, const int v) {
    return x - v < 0 ? x - v + mod : x - v;
}

//这里res是n/枚举的数
int dfs(ll res, int last, ll f){
    //最大质因子是prime[last-1] 但将1放在外面值显然一样
    int t=dec((res > M ? hou[2][n/res] : pre[2][res]),pre[2][primes[last]-1]);
    int ret= (ll)t*f%mod;//这里需修改
    for(int i=last;i<(int) primes.size();++i){
        int p = primes[i];
        if((ll)p*p > res) break;
        const int p2=(ll)p*p%mod;
        for(ll q=p,nres=res,nf=f*p%mod*(p-1)%mod;q*p<=res;q*=p){//nf需修改
            ret = add(ret,dfs(nres/=p,i+1,nf));//枚举更大的数
            nf = nf*p2%mod;//继续枚举当前素数，指数大于1时，指数每加1,nf=nf*p*p;
            ret =add(ret,nf);//指数大于1时，记上贡献
        }
    }
    return ret;
}

inline int ff(ll x){
    x%=mod;
    return x*(x+1)%mod*ni2%mod;
}

inline int fff(ll x){
    x%=mod;
    return x*(x+1)%mod*(2*x+1)%mod*ni6%mod;
}

int solve(ll n){
    M=sqrt(n);
    for(int i=0;i<3;++i){
        pre[i].clear();pre[i].resize(M+1);
        hou[i].clear();hou[i].resize(M+1);
    }
    primes.clear();primes.reserve(M+1);
    for(int i=1;i<=M;++i){
        pre[0][i]=i-1;
        hou[0][i]=(n/i-1)%mod;
        pre[1][i]=dec(ff(i),1);;
        hou[1][i]=dec(ff(n/i),1);
        pre[2][i]=dec(fff(i),1);
        hou[2][i]=dec(fff(n/i),1);
    }
    for(int p=2;p<=M;++p){
        if(pre[0][p]==pre[0][p-1]) continue;
        primes.push_back(p);
        const ll q=(ll)p*p,m=n/p;
        const int pnt0=pre[0][p-1],pnt1=pre[1][p-1],pnt2=pre[2][p-1];
        const int mid=M/p;
        const int End=min((ll)M,n/q);
        for(int i=1;i<=mid;++i){
            hou[0][i]=dec(hou[0][i],dec(hou[0][i*p],pnt0));
            hou[1][i]=dec(hou[1][i],dec(hou[1][i*p],pnt1)*(ll)p%mod);
            hou[2][i]=dec(hou[2][i],dec(hou[2][i*p],pnt2)*q%mod);
        }
        for(int i=mid+1;i<=End;++i){
            hou[0][i]=dec(hou[0][i],dec(pre[0][m/i],pnt0));
            hou[1][i]=dec(hou[1][i],dec(pre[1][m/i],pnt1)*(ll)p%mod);
            hou[2][i]=dec(hou[2][i],dec(pre[2][m/i],pnt2)*q%mod);
        }
        for(int i=M;i>=q;--i){
            pre[0][i]=dec(pre[0][i],dec(pre[0][i/p],pnt0));
            pre[1][i]=dec(pre[1][i],dec(pre[1][i/p],pnt1)*(ll)p%mod);
            pre[2][i]=dec(pre[2][i],dec(pre[2][i/p],pnt2)*q%mod);
        }
    }
    //cout<<clock()<<endl;
    primes.push_back(M+1);
    for (int i = 1; i <= M; i++) {
        pre[2][i] = dec(pre[2][i], pre[1][i]);//p^2-p
        hou[2][i] = dec(hou[2][i], hou[1][i]);
    }
    return n>1 ? add(dfs(n,0,1),1) : 1;
}

int main()
{
    //freopen("in.txt","r",stdin);
    ios::sync_with_stdio(false);
    cin>>n;
    cout<<1<<endl;
    cout<<solve(n)<<endl;
    return 0;
}
```





**例题3**     [APS2](https://www.spoj.com/problems/APS2/)              `一道不是积性函数的题，说明了非积性函数的可行性` 

定义$f(n)=n的最小质因子$，求$\sum_{i=1}^nf(i)   \ mod \ 2^{64}$     ,$1≤N≤1234567891011$   

```c++
//SPOJ  DIVCNTK - Counting Divisors (general)
//f(1)=0
//f(p)=p
//f(p^e)=p
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long u64;
u64 n,M;
vector<u64> pre[2],hou[2],primes;
u64 ff(u64 A, u64 B){
	return (A+B)%2?(B-A+1)/2*(A+B):(A+B)/2*(B-A+1);
}
u64 dfs(u64 res, int last, u64 f){
    u64 ret,t;
    if(f>0){
		t = (res > M ? hou[0][n/res] : pre[0][res]) - pre[0][primes[last]-1];//有多少个素数
		//直接-id也行   因为pre[0][primes[last]-1]=id
		ret = t * f * 1;//每个的权值这里就是f
	}
	else ret = hou[1][1];//第一次f=0  计算所有的素数的贡献
    for(int i=last;i<(int) primes.size();++i){
        int p = primes[i];
        if((u64)p*p > res) break;
        for(u64 q=p,nres=res,nf=(f==0?p:f);q*p<=res;q*=p){//f==0表明初始化
            ret += dfs (nres/=p,i+1,nf);
            ret += nf;//f==0 nf就是p  否则就是f
        }
    }
    return ret;
}
u64 solve(u64 n){
    M=sqrt(n);
    for(int i=0;i<2;++i){
        pre[i].clear();pre[i].resize(M+1);
        hou[i].clear();hou[i].resize(M+1);
    }
    primes.clear();primes.reserve(M+1);
    for(int i=1;i<=M;++i){
        pre[0][i]=i-1;
        pre[1][i]=ff(2,i);
        hou[0][i]=n/i-1;
        hou[1][i]=ff(2,n/i);
    }
    for(int p=2;p<=M;++p){
        if(pre[0][p]==pre[0][p-1]) continue;
        primes.push_back(p);
        const u64 q=(u64)p*p,m=n/p,pnt0=pre[0][p-1],pnt1=pre[1][p-1];
        const int mid=M/p;
        const int End=min((u64)M,n/q);
        for(int i=1;i<=mid;++i){
            hou[0][i]-=hou[0][i*p]-pnt0;
            hou[1][i]-=(hou[1][i*p]-pnt1)*p;
        }
        for(int i=mid+1;i<=End;++i){
            hou[0][i]-=pre[0][m/i]-pnt0;
            hou[1][i]-=(pre[1][m/i]-pnt1)*p;
        }
        for(int i=M;i>=q;--i){
            pre[0][i]-=pre[0][i/p]-pnt0;
            pre[1][i]-=(pre[1][i/p]-pnt1)*p;
        }
    }
    primes.push_back(M+1);
    return n>1 ? dfs(n,0,0) : 0;
}
int main()
{
    //freopen("in.txt","r",stdin);
    ios::sync_with_stdio(false);
    int t;
    cin>>t;
    while(t--)
    {
        cin>>n;
        cout<<solve(n)<<endl;
    }
    return 0;
}
```



## 二进制循环小数循环节

给p/q 求其转为二进制后循环节从哪开始 以及循环节的最短长度

二进制看下一位是多少即乘2  相当于左移1位  然后如果超过了分母就减去分母

举个例子  

1/10   **2**/10  4/10  8/10   16/10=6/10     32/10=**2**/10（开始循环）

所以现在的问题是

对于p/q  先出去gcd,然后要求$p*2^i\equiv p*2^j \ (mod \ q)$

变换后可得$p*2^i*(2^{j-i}-1)\equiv 0 \ (mod \ q)$  

也就是说$q \ |\ p*2^i*(2^{j-i}-1) $ 

由于p,q互质

所以$q \ |\ 2^i*(2^{j-i}-1) $

由于 $(2^{j-i}-1)$是奇数，则$q$中有多少2的次幂，$i$就是多少  且i+1就是循环节出现之前的长度，即所求

然后假设q去除完2因子之后为m  则解$2^x\equiv 1\ (mod \ m)$ 的最小解

**由欧拉定理： $a^{\varphi(m)}\equiv 1 \ (mod \ m)  \quad where \quad   gcd(a,m)=1$**    

- **注意$\varphi(m)$不一定是最小模m为1的指数，但可以证明这些指数都是$\varphi(m)$的因子。因此可以将$\varphi(m)$质因子分解，用每个素因子试除，每个素因子除到模$m$不为1为止（此时要乘回去）。**

解得的X即为最后所求循环节长度

```c++
#include<iostream>
#include<vector>
using namespace std;

typedef long long ll;

ll gcd(ll a,ll b)
{
    if(b==0) return a;
    return gcd(b,a%b);
}

ll fast_exp(ll a,ll b,ll c)
{
    ll res=1;
    while(b)
    {
        if(b&1) res=res*a%c;
        a=a*a%c;
        b>>=1;
    }
    return res;
}

ll get_phi(ll x)
{
    ll res=x;
    for(int i=2;i*i<=x;++i){
        if(x%i==0){
        res-=res/i;
        do{
            x/=i;
        }while(x%i==0);
        }
    }
    if(x>1) res-=res/x;
    return res;
}

ll string2ll(string s)
{
    ll sum=0;
    for(int i=0;i<s.size();++i){
        sum=sum*10+s[i]-'0';
    }
    return sum;
}

int main()
{
    //cout<<get_phi(10000000)<<endl;
    ios::sync_with_stdio(false);
    ll p,q;
    string s;
    int t=0;
    while(cin>>s)
    {
        std::size_t pos = s.find("/");
        p=string2ll(s.substr(0,pos));
        q=string2ll(s.substr(pos+1));
        t++;
//        if(p==0){
//            cout<<"Case #"<<t<<": "<<1<<","<<1<<endl;
//        }
        ll d=gcd(p,q);
        p=p/d;
        q=q/d;
        int i=0;
        while((q&1)==0)
        {
            q>>=1;
            i++;
        }
        ll phi=get_phi(q);
        ll tp=phi;
        vector<ll> prime;
        for(int i=2;i*i<=phi;++i){
            if(phi%i==0)
            {
                prime.push_back(i);
                do{
                    phi/=i;
                }while(phi%i==0);
            }
        }
        if(phi>1) prime.push_back(phi);
        for(int i=0;i<prime.size();++i){
            while(fast_exp(2,tp,q)==1 && tp%prime[i]==0)
            {
                tp/=prime[i];
            }
            if(fast_exp(2,tp,q)!=1) tp*=prime[i];
        }
        cout<<"Case #"<<t<<": "<<i+1<<","<<tp<<endl;
    }
    return 0;
}

```



## 因子个数最多的数

实际上，这样的数称为反素数：

![img](https://s1.ax2x.com/2018/09/03/5Bl6ky.png)



即给定$N$，求$[1,N]$之间最大的反素数**（即拥有因子数目最多的数）**

性质:

> No.1 一个反素数的质因子必然是从2开始连续的质数。 
> No.2 p=2^t1 x 3^t2 x 5^t3 x 7^t4…..必然t1>=t2>=t3>=….

暴力dfs    时间复杂度大概几个log

```c++
//51nod 1060
#include<bits/stdc++.h>
using namespace std;

typedef unsigned long long ll;

int prime[60];

bool is_prime(ll x)
{
    for(int i=2;i*i<=x;++i){
        if(x%i==0) return false;
    }
    return true;
}

int tot;
void init()
{
    tot=0;
    for(int i=2;i<2000&&(tot<20);++i){
        if(is_prime(i)){
            prime[++tot]=i;
        }
    }
}

ll ans,res;
ll up;

void dfs(int last,ll cur,ll num,int pre)//last 是最后一个访问的素数下标  cur是当前数 num是当前数的约数个数   pre是上一次的指数
{
    if(last>=tot) return ;
    if(num>ans){
        res=cur;//当前数
        ans=num;//约数个数
    }
    else if(num==ans){
        res=min(res,cur);
    }
    for(int i=1;i<=61 && i<=pre;++i){//枚举指数
        if(cur<=up/prime[last+1]){
            //cout<<cur<<endl;
            cur*=prime[last+1];
            dfs(last+1,cur,num*(i+1),i);
        }
        else break;
    }
}

int main()
{
    init();
    //cout<<tot<<endl;
    //for(int i=1;i<=tot;++i) cout<<prime[i]<<" ";
    int t;
    cin>>t;
    while(t--)
    {
        ans=0;
        cin>>up;
        dfs(0,1,1,61);
        cout<<res<<" "<<ans<<endl;//该数和因子数目   若因子数目相同则输出最小的数
    }
    return 0;
}

```



	